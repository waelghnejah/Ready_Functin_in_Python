import tkinter as tk
from tkinter import ttk, messagebox
import math, cmath, ast, random
import datetime
from zoneinfo import ZoneInfo
import calendar
from tkinter.scrolledtext import ScrolledText

# الواجهة الرئيسية
root = tk.Tk()
root.title("دوال البايثون الجاهزة")

# تحوّل الأمثلة القديمة التي تستخدم "input" إلى الشكل الموحد "inputs" ضمن كل دالة في قاعدة البيانات.
def unify_inputs(data):
    for section in data.values():
        for funcs in section.values():
            for f in funcs.values():
                if "examples" in f:
                    for ex in f["examples"]:
                        # إذا المفتاح اسمه input غيّره لـ inputs
                        if "input" in ex and "inputs" not in ex:
                            ex["inputs"] = ex["input"]
                            del ex["input"]
    return data

# تقيّم التعبير الرياضي أو المركب بأمان، مع دعم الثوابت مثل pi و e، ومنع أي مدخلات غير آمنة.
def safe_eval(expr):
    # السماح بالحروف المستخدمة في الأعداد المركبة
    allowed = "0123456789+-*/(). piej "
    if not all(c in allowed for c in expr):
        raise ValueError("مدخل غير آمن")

    # استبدال الثوابت
    expr = expr.replace("pi", str(math.pi)).replace("e", str(math.e))

    try:
        # إذا كان مجرد رقم أو ثابت
        return ast.literal_eval(expr)
    except:
        # إذا كان تعبير حسابي أو عدد مركب
        return eval(expr, {"__builtins__": None}, {"j": 1j})
    
# تُعيد ترتيب الأحرف إذا كان المدخل نصًا، أو تُعيد ترتيب الكلمات إذا كان سلسلة مفصولة بفواصل.    
def my_shuffle(vals):
    if isinstance(vals[0], str) and "," not in vals[0]:
        return "".join(random.sample(vals[0], len(vals[0])))
    else:
        seq = [v.strip() for v in vals[0].split(",")]
        return random.sample(seq, len(seq))  # فقط خلط ترتيب الكلمات، بدون خلط أحرفها

# تحسب عدد مرات ظهور سلسلة فرعية داخل نص، مع دعم تحديد بداية ونهاية النطاق بشكل اختياري.   
def count_substring(vals):
    text = vals[0]
    sub = vals[1]
    start = int(vals[2]) if len(vals) > 2 and vals[2].strip() else None
    end = int(vals[3]) if len(vals) > 3 and vals[3].strip() else None

    if start is not None and end is not None:
        return str(text.count(sub, start, end))
    elif start is not None:
        return str(text.count(sub, start))
    else:
        return str(text.count(sub))

# تُرجع موقع أول ظهور للسلسلة الفرعية داخل النص، مع دعم تحديد بداية ونهاية النطاق بشكل اختياري.
def find_substring(vals):
    text = vals[0]                      # النص الكامل
    sub = vals[1]                       # السلسلة الفرعية المراد البحث عنها
    start = int(vals[2]) if len(vals) > 2 and vals[2].strip() else None
    end = int(vals[3]) if len(vals) > 3 and vals[3].strip() else None

    if start is not None and end is not None:
        return str(text.find(sub, start, end))
    elif start is not None:
        return str(text.find(sub, start))
    else:
        return str(text.find(sub))

# تُرجع موقع آخر ظهور للسلسلة الفرعية داخل النص، مع دعم تحديد بداية ونهاية النطاق بشكل اختياري.    
def rfind_substring(vals):
    text = vals[0]                      # النص الكامل
    sub = vals[1]                       # السلسلة الفرعية المراد البحث عنها
    start = int(vals[2]) if len(vals) > 2 and vals[2].strip() else None
    end = int(vals[3]) if len(vals) > 3 and vals[3].strip() else None
    if start is not None and end is not None:
        return str(text.rfind(sub, start, end))
    elif start is not None:
        return str(text.rfind(sub, start))
    else:
        return str(text.rfind(sub))

# تُرجع موقع أول ظهور للسلسلة الفرعية داخل النص مع دعم نطاق البداية والنهاية، وتُظهر رسالة خطأ إذا لم يتم العثور عليها.
def index_substring(vals):
    text = vals[0]
    sub = vals[1]
    start = int(vals[2]) if len(vals) > 2 and vals[2].strip() else None
    end = int(vals[3]) if len(vals) > 3 and vals[3].strip() else None

    try:
        if start is not None and end is not None:
            return str(text.index(sub, start, end))
        elif start is not None:
            return str(text.index(sub, start))
        else:
            return str(text.index(sub))
    except ValueError:
        return "ValueError: السلسلة الفرعية غير موجودة"

# تُرجع موقع آخر ظهور للسلسلة الفرعية داخل النص مع دعم نطاق البداية والنهاية، وتُظهر رسالة خطأ إذا لم يتم العثور عليها.
def rindex_substring(vals):
    text = vals[0]
    sub = vals[1]
    start = int(vals[2]) if len(vals) > 2 and vals[2].strip() else None
    end = int(vals[3]) if len(vals) > 3 and vals[3].strip() else None

    try:
        if start is not None and end is not None:
            return str(text.rindex(sub, start, end))
        elif start is not None:
            return str(text.rindex(sub, start))
        else:
            return str(text.rindex(sub))
    except ValueError:
        return "ValueError: السلسلة الفرعية غير موجودة"

# تقسّم النص إلى قائمة أجزاء باستخدام فاصل محدد (أو المسافات افتراضيًا)، مع إمكانية تحديد عدد مرات التقسيم.
def split_substring(vals):
    text = vals[0]
    sep = vals[1] if len(vals) > 1 and vals[1].strip() else None
    maxsplit = int(vals[2]) if len(vals) > 2 and vals[2].strip() else -1

    if sep is None:
        return str(text.split()) if maxsplit == -1 else str(text.split(None, maxsplit))
    else:
        return str(text.split(sep)) if maxsplit == -1 else str(text.split(sep, maxsplit))

# تحوّل النص إلى أسطر منفصلة باستخدام دالة splitlines، بعد معالجة الرموز الخاصة مثل \n و \r، ثم تُعيدها كسلسلة متعددة الأسطر.
def splitlines_substring(vals):
    s = vals[0]
    s = s.replace("\\r\\n", "\r\n").replace("\\n", "\n").replace("\\r", "\r")
    arr = s.splitlines()
    return "\n".join(arr)

# تستبدل جميع أو عدد محدد من مرات ظهور سلسلة فرعية داخل النص بسلسلة جديدة.
def replace_substring(vals):
    text = vals[0]
    old = vals[1]
    new = vals[2]
    count = int(vals[3]) if len(vals) > 3 and vals[3].strip() else -1

    if count == -1:
        return text.replace(old, new)
    else:
        return text.replace(old, new, count)

# تُحوّل النص عبر جدول تحويل يحدد الحروف المراد استبدالها أو حذفها، باستخدام دالة translate.
def translate_substring(vals):
    """
    vals[0] = النص الأصلي
    vals[1] = الحروف المراد استبدالها (x)
    vals[2] = الحروف البديلة (y) أو فارغ
    vals[3] = الحروف المراد حذفها (z) أو فارغ
    """
    text = vals[0]
    x = vals[1] if len(vals) > 1 and vals[1].strip() else ""
    y = vals[2] if len(vals) > 2 and vals[2].strip() else ""
    z = vals[3] if len(vals) > 3 and vals[3].strip() else ""

    table = str.maketrans(x, y, z) if (x or y or z) else {}
    return text.translate(table)

# تُدمج العناصر في نص واحد باستخدام فاصل محدد؛ إذا كان المدخل قائمة كلمات مفصولة بفواصل تُدمج ككلمات، وإذا كان نصًا عاديًا تُدمج أحرفه.
def smart_join(vals):
    sep = vals[0]
    raw = vals[1]

    # إذا كانت قائمة كلمات مفصولة بفواصل
    if "," in raw:
        items = [v.strip() for v in raw.split(",")]
        return sep.join(items)
    else:
        return sep.join(list(raw))

# تتحقق مما إذا كان النص يبدأ بسلسلة معينة أو أي سلسلة من مجموعة (tuple)، مع دعم نطاق البداية والنهاية، وتُعيد False عند حدوث خطأ.
def check_start(text, sub, start=None, end=None):
    try:
        if isinstance(sub, tuple):
            return any(text.startswith(s, start, end) for s in sub)
        else:
            return text.startswith(sub, start, end)
    except TypeError:
        return False

# تتحقق مما إذا كان النص ينتهي بسلسلة معينة أو أي سلسلة من مجموعة (tuple)، مع دعم نطاق البداية والنهاية، وتُعيد False عند حدوث خطأ.
def check_end(text, sub, start=None, end=None):
    try:
        if isinstance(sub, tuple):
            return any(text.endswith(s, start, end) for s in sub)
        else:
            return text.endswith(sub, start, end)
    except TypeError:
        return False

# ✅ دالة ذكية تضيف عنصر إلى القائمة باستخدام append أو extend أو insert حسب الحاجة

# ✅ دالة smart_add المعدّلة لضمان التمييز بين append و extend و insert
# --------------------------------------------------

# ✅ النسخة المعدّلة من الدالة smart_add
# --------------------------------------------------
# تضيف عنصر إلى القائمة باستخدام append أو extend أو insert حسب الوضع المطلوب،
# مع فحص نوع العنصر وتحويله تلقائيًا، وتقييد extend لتعمل فقط مع القوائم.

# تضيف عنصرًا إلى القائمة بذكاء باستخدام append أو extend أو insert حسب الوضع المطلوب:
#- إذا كان العنصر نصًا يمثل قائمة، يتم تحويله تلقائيًا إلى كائن list.
#- إذا كان العنصر رقمًا، يُحوّل إلى int أو float.
#- عند اختيار extend، يُسمح فقط بالقوائم.
#- عند اختيار insert، يُستخدم الفهرس المحدد.
#- الوضع الافتراضي أو append يضيف العنصر مباشرة.
def smart_add(lst, item, mode="auto", index=None):
    try:
        # تحويل القائمة من نص إلى كائن بايثوني
        if isinstance(lst, str):
            if not (lst.startswith("[") and lst.endswith("]")):
                raise ValueError("القائمة يجب أن تبدأ بـ [ وتنتهي بـ ]")
            lst = ast.literal_eval(lst)

        # تحويل العنصر من نص إلى كائن إذا كان يمثل قائمة
        if isinstance(item, str) and item.startswith("[") and item.endswith("]"):
            item = ast.literal_eval(item)

        # تحويل تلقائي للعنصر إذا كان يمثل رقم
        try:
            item = int(item)
        except (ValueError, TypeError):
            try:
                item = float(item)
            except (ValueError, TypeError):
                pass  # يبقى كنص

        # اختيار طريقة الإضافة
        if mode == "insert" and index is not None:
            lst.insert(index, item)

        elif mode == "extend":
            # ✅ نقيّد الاستخدام ليقبل فقط القوائم
            if isinstance(item, list):
                lst.extend(item)
            else:
                raise ValueError("❌ خطأ: يجب أن يكون العنصر من نوع list عند استخدام extend")

        elif mode == "append" or mode == "auto":
            lst.append(item)

        else:
            raise ValueError("❌ خطأ: طريقة الإضافة غير مدعومة")

        return lst

    except Exception:
        return "❌ خطأ: تأكد من صحة القائمة وطريقة الإضافة"

# تُحوّل القائمة إلى نص منسّق يظهر عناصرها بنفس طريقة بايثون (باستخدام repr)، داخل أقواس مربعة ومفصولة بفواصل.
def format_list(lst):
    return "[" + ", ".join(map(repr, lst)) + "]"

# ✅ دالة تحاكي list.pop() مع عرض العنصر المحذوف والقائمة بعد الحذف

# تنفّذ عمليات الحذف على القوائم بطرق مختلفة:
# - pop : يحذف العنصر الأخير أو عنصرًا عند فهرس محدد.
# - remove : يحذف عنصرًا محددًا إذا كان موجودًا.
# - clear : يحذف جميع العناصر ويعيد قائمة فارغة.
# مع التحقق من صحة المدخلات وإرجاع رسائل خطأ واضحة عند الحاجة.
def list_action(lst, mode="pop", value=None, index=None):

    if isinstance(lst, str):
        lst = ast.literal_eval(lst)

    if not isinstance(lst, list):
        return "❌ خطأ: المدخل ليس قائمة صالحة"

    if mode == "pop":
        try:
            removed = lst.pop() if index is None else lst.pop(int(index))
            return f"العنصر المحذوف: {repr(removed)}\nالقائمة بعد الحذف: {format_list(lst)}"
        except IndexError:
            return "❌ خطأ: الفهرس غير صالح أو القائمة فارغة"

    elif mode == "remove":
        try:
            value = auto_cast(value)
            if value not in lst:
                return f"❌ ValueError : العنصر {repr(value)} غير موجود في القائمة"
            lst.remove(value)
            return f"تم حذف العنصر: {repr(value)}\nالقائمة بعد الحذف: {format_list(lst)}"
        except Exception:
            return "❌ خطأ غير متوقع أثناء الحذف"

    elif mode == "clear":
        lst.clear()
        return "✅ تم حذف جميع العناصر\nالقائمة الآن: []"

    else:
        return "❌ خطأ: نوع العملية غير معروف"

# تحلّل المدخل النصي بذكاء:
# - إذا كان النص محاطًا بتنصيص، يُعاد كما هو بعد إزالة التنصيص.
# - إذا كان تعبيرًا رياضيًا، يتم استبدال الثوابت (pi و e) بقيمها العددية.
# - يُجرَّب تقييم المدخل باستخدام literal_eval أولًا، ثم eval مع دعم الأعداد المركبة (j).
# - في حال الفشل، تُرجع رسالة خطأ واضحة.
def parse_input(expr):
    # إذا المدخل نص محاط بتنصيص، نرجعه كما هو
    if (expr.startswith("'") and expr.endswith("'")) or (expr.startswith('"') and expr.endswith('"')):
        try:
            return ast.literal_eval(expr)  # يرجع النص بدون تنصيص إضافي
        except:
            return "❌ خطأ: النص غير صالح"

    # استبدال الثوابت فقط في التعابير الرياضية
    expr = expr.replace("pi", str(math.pi)).replace("e", str(math.e))

    try:
        return ast.literal_eval(expr)
    except:
        try:
            return eval(expr, {"__builtins__": None}, {"j": 1j, "pi": math.pi, "e": math.e})
        except:
            return "❌ خطأ: المدخل غير صالح"

# تبحث عن موقع عنصر داخل قائمة مع دعم النطاقات:
# - إذا كانت القائمة نصية أو خليطة، يبقى العنصر كما هو.
# - إذا كانت القائمة رقمية بالكامل، يتم تحويل العنصر تلقائيًا (مثل "2" → 2).
# - يمكن تحديد بداية ونهاية البحث باستخدام start و end.
# - عند عدم العثور على العنصر، تُرجع رسالة خطأ واضحة.
def try_index(lst, x, start, end):
    # 1) تحويل lst من نص إلى list إذا جاء من Entry
    if isinstance(lst, str):
        try:
            lst = ast.literal_eval(lst)
        except Exception:
            return "❌ خطأ: القائمة غير قابلة للتقييم. اكتبها مثل: [1, 2, 3] أو ['a', 'b']"

    # 2) التحقق أن المدخل قائمة فعلًا
    if not isinstance(lst, list):
        return "❌ خطأ: هذا القسم مخصص للقوائم فقط"

    # 3) تحديد طبيعة العناصر داخل القائمة
    def is_numeric(v):
        return isinstance(v, (int, float))

    all_numeric = all(is_numeric(v) for v in lst)

    # 4) تحويل x فقط إذا كانت القائمة رقمية بالكامل
    if all_numeric:
        x = auto_cast(x)  # "2" → 2
    else:
        # إذا القائمة نصية أو خليطة، نخلي x كما هو (لا نغيّر نوعه)
        # هذا بيضمن مطابقة "2" مع "2" داخل القائمة النصية
        pass

    # 5) تحويل start/end إن وُجدت
    start = int(start) if isinstance(start, str) and start.strip() else None
    end = int(end) if isinstance(end, str) and end.strip() else None

    # 6) التنفيذ مع دعم النطاقات
    try:
        if start is not None and end is not None:
            return lst.index(x, start, end)
        elif start is not None:
            return lst.index(x, start)
        else:
            return lst.index(x)
    except ValueError:
        return f"❌ ValueError: العنصر {repr(x)} غير موجود في القائمة"

# ترتّب عناصر القائمة تصاعديًا بشكل افتراضي، أو تنازليًا إذا كان reverse = "True".
# - إذا كان المدخل نصًا يمثل قائمة، يتم تحويله أولًا إلى كائن list.
# - عند نجاح العملية، تُرجع القائمة بعد الترتيب بشكل منسّق.
# - إذا كانت العناصر غير قابلة للمقارنة (مثل خلط أعداد مع نصوص)، تُرجع رسالة خطأ واضحة.
def sort_list(lst, reverse="False"):
    if isinstance(lst, str):
        lst = ast.literal_eval(lst)

    if not isinstance(lst, list):
        return "❌ خطأ: المدخل ليس قائمة"

    try:
        lst.sort(reverse=(reverse.lower() == "true"))
        return f"✅ تم الترتيب بنجاح:\n{format_list(lst)}"
    except Exception:
        return "❌ خطأ: تأكد أن جميع عناصر القائمة قابلة للمقارنة" 

# تعكس ترتيب عناصر القائمة:
# - إذا كان المدخل نصًا يمثل قائمة، يتم تحويله أولًا إلى كائن list.
# - إذا لم يكن المدخل قائمة، تُرجع رسالة خطأ.
# - عند النجاح، تُرجع القائمة بعد عكس ترتيبها بشكل منسّق.
def reverse_list(lst):
    import ast
    if isinstance(lst, str):
        lst = ast.literal_eval(lst)

    if not isinstance(lst, list):
        return "❌ خطأ: المدخل ليس قائمة"

    lst.reverse()
    return f"✅ تم عكس ترتيب العناصر:\n{format_list(lst)}"

# التحقق من النوع المطلوب فقط و منع الأنواع الأخرى داخل قسم set
def strict_type(expected, value):
    try:
        obj = eval(value)
    except:
        return "❌ خطأ: المدخل غير قابل للتقييم"

    # التحقق من النوع المطلوب فقط
    if expected == "list" and not isinstance(obj, list):
        return "❌ خطأ: هذا القسم مخصص للقوائم (list) فقط"
    elif expected == "tuple" and not isinstance(obj, tuple):
        return "❌ خطأ: هذا القسم مخصص للصفوف (tuple) فقط"
    elif expected == "set" and not isinstance(obj, set):
        return "❌ خطأ: هذا القسم مخصص للمجموعات (set) فقط"
    
    # منع الأنواع الأخرى داخل قسم set
    if expected == "set" and isinstance(obj, (list, tuple)):
        return "❌ خطأ: لا يُسمح بإدخال قائمة أو صف داخل قسم المجموعات"

    return obj

# تبحث عن موقع عنصر داخل صف (tuple) مع دعم النطاقات:
# - يتم أولًا التحقق من أن المدخل صف صالح باستخدام strict_type.
# - يُحوَّل العنصر تلقائيًا عبر auto_cast إذا كان يمثل رقمًا.
# - يمكن تحديد بداية ونهاية البحث باستخدام start و end.
# - عند عدم العثور على العنصر، تُرجع رسالة خطأ واضحة.
def tuple_index(tpl, x, start="", end=""):
    tpl = strict_type("tuple", tpl)
    if not isinstance(tpl, tuple):
        return tpl  # رسالة خطأ من strict_type

    try:
        x = auto_cast(x)
        start = int(start) if isinstance(start, str) and start.strip() else None
        end = int(end) if isinstance(end, str) and end.strip() else None

        if start is not None and end is not None:
            return tpl.index(x, start, end)
        elif start is not None:
            return tpl.index(x, start)
        else:
            return tpl.index(x)

    except ValueError:
        return "❌ خطأ: القيمة ليست في هذا المجال"

# تتحقق هذه الدالة من أن المدخل يمثل مجموعة (set) فقط:
# - إذا لم يكن المدخل قابلًا للتقييم، تُرجع رسالة خطأ.
# - إذا لم يكن المدخل من نوع set، تُرجع رسالة خطأ مخصصة.
# - تمنع وجود عناصر من نوع list أو tuple داخل المجموعة.
# - عند النجاح، تُرجع المجموعة كما هي.
# - استخدام eval هنا قد يكون خطرًا لأنه ينفّذ أي كود مكتوب داخل النص. الأفضل استبداله بـ ast.literal_eval لضمان الأمان عند تقييم المدخلات النصية.
def set_strict(value):
    try:
        obj = eval(value)
    except:
        return "❌ خطأ: المدخل غير قابل للتقييم"

    # التحقق أن المدخل مجموعة فقط
    if not isinstance(obj, set):
        return "❌ خطأ: هذا القسم مخصص للمجموعات (set) فقط"

    # منع الأنواع الأخرى داخل المجموعة (مثلاً قائمة أو صف)
    for item in obj:
        if isinstance(item, (list, tuple)):
            return "❌ خطأ: لا يُسمح بإدخال قائمة أو صف داخل المجموعة"

    return obj

# تحاول هذه الدالة تحويل النص إلى قيمة بايثونية بشكل آمن باستخدام ast.literal_eval:
# - إذا كان النص يمثل قيمة بسيطة (عدد، نص، قيمة منطقية...) يتم تحويله وإرجاعه.
# - إذا كان النص يمثل تركيبًا (list / tuple / set / dict) تُرجع رسالة خطأ تمنع إدخاله كعنصر داخل مجموعة.
# - إذا فشل التفسير، يُعاد النص كما هو.
def cast_element(s):
    # محاولة تفسير القيمة حرفياً بشكل آمن
    try:
        val = ast.literal_eval(s)
    except:
        # إذا فشل التفسير، نُبقيها كنص كما هي
        return s

    # منع إدخال تراكيب داخل set
    if isinstance(val, (list, tuple, set, dict)):
        return "❌ خطأ: لا يُسمح بإدخال تراكيب (list/tuple/set/dict) كعنصر داخل المجموعة"
    return val

# تُعيد قيمة مفتاح من قاموس مع خيار توفير قيمة افتراضية:
# - يتم قراءة القاموس والمفتاح والقيمة الافتراضية من حقول الإدخال.
# - إذا وُجدت قيمة افتراضية، تُستخدم عند غياب المفتاح.
# - إذا لم توجد، تُرجع None عند غياب المفتاح.
# - في حال حدوث خطأ أثناء التقييم أو القراءة، تُرجع رسالة خطأ واضحة.
# - استخدام eval هنا قد يكون خطرًا لأنه ينفّذ أي كود مكتوب داخل النصوص. الأفضل استبداله بـ ast.literal_eval لضمان الأمان عند تفسير المدخلات.
def get_logic():
    try:
        d = eval(inputs[0]["text"].get("1.0", "end").strip())     # القاموس
        k = eval(inputs[1]["text"].get("1.0", "end").strip())     # المفتاح
        default_text = inputs[2]["text"].get("1.0", "end").strip()
        if default_text:
            v = eval(default_text)
            return d.get(k, v)
        else:
            return d.get(k)
    except Exception as e:
        return f"خطأ: {e}"


def merge_dicts(dict_str, other_dict_str):
    try:
        d = ast.literal_eval(dict_str)          # تحويل النص إلى قاموس
        other = ast.literal_eval(other_dict_str) # تحويل النص إلى قاموس ثاني
        if not isinstance(d, dict) or not isinstance(other, dict):
            return "❌ خطأ: المدخلات يجب أن تكون قواميس"
        d.update(other)  # دمج القاموسين
        return d         # إرجاع القاموس بعد الدمج
    except Exception as e:
        return f"❌ خطأ: {e}"   

# دالة عرض الوقت والتاريخ الحالي بدقة
def show_datetime_now():
    import datetime
    import pytz

    tz = pytz.timezone("Asia/Damascus")
    now = datetime.datetime.now()
    now_with_tz = datetime.datetime.now(tz)

    return (
        f"الوقت الحالي باستخدام now(): {now}\n"
        f"now with timezone: {now_with_tz}"
    )


# دالة عرض الوقت والتاليخ الحالي باستخدام اليوم
def show_datetime_today():
    import datetime
    today = datetime.datetime.today()

    return (
        f"الوقت الحالي باستخدام today(): {today}\n"
        f"today (no timezone): {today}"
    )

# utc عرض الوقت والتاريخ الحالي باستخدام
def show_datetime_utcnow():
    import datetime
    utc_now = datetime.datetime.utcnow()
    return (
        f"الوقت الحالي باستخدام utcnow(): {utc_now}\n"
        f"utcnow (no timezone info): {utc_now}"
    )

def show_datetime_fromtimestamp(ts):
    import datetime
    try:
        ts = int(ts)
        dt = datetime.datetime.fromtimestamp(ts)
        return f"رقم timestamp: {ts}\nالتاريخ والوقت الموافق له: {dt}"
    except Exception as e:
        return f"⚠️ خطأ: {str(e)}"

               
# قاعدة بيانات الدوال (للأعداد فقط حالياً)
functions_data = {
    "الأعداد": {
        "دوال التحويل بين أنواع الأعداد": {
            "int(x)": {
                "definition": "تحويل الكائن x إلى عدد صحيح.",
                "syntax": "int(x)",
                "params": "x: يمكن أن يكون كائن من أي نوع بشرط أن يكون يمثل قيمة عددية ",
                "return": "عدد صحيح",
                "examples": [
                    {
                        "title": "مثال 1: تحويل عدد عشري",
                        "inputs": ["عدد عشري (مثلاً: 12.7)"],
                        "logic": lambda vals: int(float(vals[0]))
                    },
                    {
                        "title": "مثال 2: تحويل نص إلى عدد",
                        "inputs": ["نص يمثل عدد (مثلاً: '123')"],
                        "logic": lambda vals: int(vals[0])
                    }
                ]
            },
            "int(x, base)": {
                "definition": "تحويل نص يمثل عدد في نظام عددي معين إلى عدد صحيح.",
                "syntax": "int(x, base)",
                "params": "أدخل الرقم والأساس مفصولين بفاصلة (مثال: 1011,2 أو A03,16 أو 42,8)",
                "return": "عدد صحيح",
                "examples": [
                    {
                        "title": "مثال 1: تحويل من اي نظام ",
                        "inputs": ["أدخل الرقم والأساس مفصولين بفاصلة (مثال: 1011,2 أو A03,16)"],
                        "logic": lambda vals: int(vals[0].split(",")[0], int(vals[0].split(",")[1]))
                    }
                ]
            },
            "float(x)": {
                "definition": "تحويل القيمة إلى عدد عشري (float).",
                "syntax": "float(x)",
                "params": "x: عدد صحيح أو نص يمثل عدد",
                "return": "عدد عشري",
                "examples": [
                    {
                        "title": "مثال 1: تحويل عدد صحيح",
                        "inputs": ["عدد صحيح"],
                        "logic": lambda vals: float(vals[0])
                    }
                ]
            },
            "complex(x, y)": {
                "definition": "إنشاء عدد مركب من جزئين (حقيقي وتخيلي).",
                "syntax": "complex(x, y)",
                "params": "x: الجزء الحقيقي, y: الجزء التخيلي",
                "return": "عدد مركب",
                "examples": [
                    {
                        "title": "مثال 1: عدد مركب",
                        "inputs": ["الجزء الحقيقي", "الجزء التخيلي"],
                        "logic": lambda vals: complex(float(vals[0]), float(vals[1]))
                    }
                ]
            },
            "bool(x)": {
                "definition": "تحويل القيمة إلى قيمة منطقية (True/False).",
                "syntax": "bool(x)",
                "params": "x: أي قيمة",
                "return": "True أو False",
                "examples": [
                    {
                        "title": "مثال 1: قيمة منطقية",
                        "inputs": ["قيمة"],
                        "logic": lambda vals: bool(eval(vals[0]))
                    }
                ]
            }
        },
        "دوال التعامل مع الاعداد": {
            "abs(x)":{
                "definition": "x ترجع القيمة المطلقة للعدد الذي نمرره لها مكان الباراميتر ",
                "syntax": "abs(x)",
                "params": "x عبارة عن عدد ليس له نوع محدد.",
                "return": "عدد موجب ",
                "examples": [
                    {
                        "title": "مثال 1: قيمة مطلقة",
                        "inputs": [" قيمة موجبة أو سالبة"],
                        "logic": lambda vals: abs(float(vals[0]))
                    }
                ]
            },
        "round(x,n)":{
                "definition": "x = number  ترجع أقرب عدد صحيح للعدد الذي نمرره لها مكان الباراميتر ",
                "syntax": "round(x,n)",
                "params": "x: رقم عشري،\n n: عدد صحيح يحدد عدد المنازل العشرية بعد الفاصلة (اختياري، القيمة الافتراضية = 0)",
                "return": "x ترجع أقرب عدد صحيح للعدد الذي نمرره لها مكان الباراميتر",
                "examples": [
                     {
                        "title": "مثال عن التقريب",
                        "inputs": ["أدخل الرقم العشري", "أدخل عدد المنازل العشرية\n (مثال: 1 أو 2)"],
                        "logic": lambda vals: round(float(vals[0]),int(vals[1]))
                     }
                 ]
            },
            "max(x1,x2,...) or max(array)":{
                "definition": "تُستخدم هذه الدالة لاستخراج أكبر قيمة من مجموعة أعداد.\n يمكن تمرير الأعداد بشكل مباشر مفصولة بفواصل،\n (tuple مثل قائمة أو ) أو وضعها داخل مصفوفة .\n الدالة تقارن القيم وتعيد الأكبر بينها.",
                "syntax": "لها شكلان:\n# الشكل الأول\nmax(iterable, *[, key, default])\n\n# الشكل الثاني\nmax(arg1, arg2, *args[, key])",
                "params": "يمكن استدعاء هذه الدالة بطريقتين:\n• [] or () يمكن تمرير مصفوفة من الأعداد لها مع وضع عناصرها بين  .\n• ويمكن تمرير أي عدد من الأعداد لها مع وضع فاصلة بين كل عددين.\n\nباراميترات اختيارية:\n• key: (مثلاً: key=len لاختيار العنصر الأطول) تُستخدم لتحديد معيار المقارنة بين العناصر .\n• default: تُستخدم لتحديد قيمة تُعاد في حال كانت القائمة فارغة، لتجنّب حدوث خطأ.",
                "return": "ترجع العدد الأكبر من بين مجموعة الأعداد التي يتم تمريرها لها عند استدعائها.",
                "examples": [
                     {
                         "title": "مثال عن الحصول على اكبر قيمة ",
                         "inputs": [
                                      " مجموعة من الأرقام (مثال: 5, 8, 2 أو [5, 8, 2])",
                                      " معيار المقارنة (اختياري، مثال: len لاختيار العنصر الأطول)",
                                      " القيمة الافتراضية في حال كانت القائمة فارغة (اختياري، مثال: لا يوجد عناصر)"
                                    ],
                        "logic": lambda vals: max(
                            eval(vals[0]) if vals[0].startswith("[") or vals[0].startswith("(") else [float(x) for x in vals[0].split(",")],
                            **({"key": eval(vals[1])} if len(vals) > 1 and vals[1] else {}),
                            **({"default": vals[2]} if len(vals) > 2 and vals[2] else {})
                        )
                     }
                 ]
            },
            "min(x1,x2,...) or min(array)":{
                "definition": "تُستخدم هذه الدالة لاستخراج أصغر قيمة من مجموعة أعداد.\n يمكن تمرير الأعداد بشكل مباشر مفصولة بفواصل،\n (tuple مثل قائمة أو ) أو وضعها داخل مصفوفة .\n الدالة تقارن القيم وتعيد الأصغر بينها.",
                "syntax": "لها شكلان:\n# الشكل الأول\nmin(iterable, *[, key, default])\n\n# الشكل الثاني\nmin(arg1, arg2, *args[, key])",
                "params": "يمكن استدعاء هذه الدالة بطريقتين:\n• [] or () يمكن تمرير مصفوفة من الأعداد لها مع وضع عناصرها بين  .\n• ويمكن تمرير أي عدد من الأعداد لها مع وضع فاصلة بين كل عددين.\n\nباراميترات اختيارية:\n• key: (مثلاً: key=len لاختيار العنصر الأقصر) تُستخدم لتحديد معيار المقارنة بين العناصر .\n• default: تُستخدم لتحديد قيمة تُعاد في حال كانت القائمة فارغة، لتجنّب حدوث خطأ.",
                "return": "ترجع العدد الأصغر من بين مجموعة الأعداد التي يتم تمريرها لها عند استدعائها.",
                "examples": [
                     {
                         "title": "مثال عن الحصول على أصغر قيمة ",
                         "inputs": [
                                      " مجموعة من الأرقام (مثال: 5, 8, 2 أو [5, 8, 2])",
                                      " معيار المقارنة (اختياري، مثال: len لاختيار العنصر الأقصر)",
                                      " القيمة الافتراضية في حال كانت القائمة فارغة (اختياري، مثال: لا يوجد عناصر)"
                                    ],
                        "logic": lambda vals: min(
                            eval(vals[0]) if vals[0].startswith("[") or vals[0].startswith("(") else [float(x) for x in vals[0].split(",")],
                            **({"key": eval(vals[1])} if len(vals) > 1 and vals[1] else {}),
                            **({"default": vals[2]} if len(vals) > 2 and vals[2] else {})
                        )
                     }
                 ]
            },
            "isinstance(x,type)":{
                "definition": "تتحقق من نوع المتغير هل هو من نوع معين ",
                "syntax": "isinstance(x,type)",
                "params": "x: المتغير المراد فحصه.\n type : (مثل int, float, str) النوع المراد التحقق منه",
                "return": "True : إذا كان x من النوع المحدد، وإلا False",
                "examples": [
                    {
                        "title": "مثال",
                        "input": ["المتغير المراد فحصه","النوع المراد التحقق منه"],
                        "logic": lambda vals: isinstance(eval(vals[0]),eval(vals[1]))
                    }
                ]
            },
        },
        "math Module":{
            "ceil(x)":{
                "definition": "x ترجع العدد الصحيح الأكبر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر",
                "syntax": "math.ceil(x)",
                "params": "x: عبارة عن عدد ليس له نوع محدد.",
                "return": "x ترجع العدد الصحيح الأكبر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["االرقم"],
                        "logic": lambda vals: math.ceil(float(vals[0]))
                    }
                ]
            },
            "floor(x)":{
                "definition": "x ترجع العدد الصحيح الأصغر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر",
                "syntax": "math.floor(x)",
                "params": "x: عبارة عن عدد ليس له نوع محدد.",
                "return": "x ترجع العدد الصحيح الأصغر أو الذي يساوي العدد الذي نمرره لها مكان الباراميتر",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["االرقم"],
                        "logic": lambda vals: math.floor(float(vals[0]))
                    }
                ]
            },
            "pow(x,y)": {
                "definition": " مرة  y مكرّرًا  x أي ,y للقوة  xترجع ناتج رفع العدد  .",
                "syntax": "math.pow(x, y)",
                "params": "x, y: أعداد يمكن أن تكون صحيحة أو عشرية.",
                "return": "float: ناتج العملية كعدد عشري، حتى لو كانت القيم صحيحة.",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x", "y"],
                         "logic" : lambda vals: math.pow(safe_eval(vals[0]), safe_eval(vals[1]))
                    }
                ]
            },
            "sqrt(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  ( Square Root ) ترجع قيمة الجذر التربيعي  ",
                "syntax": "math.sqrt(x)",
                "params": "x: عبارة عن عدد ليس له نوع محدد.",
                "return": "float كعدد عشري نوعه  x ترجع قيمة الجذر التربيعي للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x"],
                         "logic" : lambda vals: math.sqrt(float(vals[0]))
                    }
                ]
            },
            "exp(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  ( Exponential ) ترجع قيمة المتسارع .\n  e = 2.718281828459045 : x مضاعفة بقيمة  e أي قيمة  e**x قيمة المتسارع تساوي  ",
                "syntax": "math.exp(x)",
                "params": "x: عبارة عن عدد ليس له نوع محدد.",
                "return": "  x ترجع قيمة المتسارع للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x"],
                         "logic": lambda vals: math.exp(safe_eval(vals[0]))
                    }
                ]
            },
            "log(x,base)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  ( Logarithm ) ترجع قيمة اللوغارتم .\n  مع إمكانية تحديد نوع الوحدة لهذا العدد.\n  in mathmetics:  log2(8) = log(8,2) = 3   ... 2^3 = 8",
                "syntax": "math.log(x,base)",
                "params": " x: عبارة عن عدد ليس له نوع محدد.\n • x باراميتر إختياري و هو عبارة عن عدد صحيح يمثل وحدة الباراميتر base \n مكانه. e في حال لم يتم تمرير قيمة مكانه سيتم إعتبار أنه تم تمرير قيمة المتسارع ",
                "return": "  x ترجع قيمة اللوغاريتم  للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x", "base"],
                         "logic": lambda vals: math.log(safe_eval(vals[0]),safe_eval(vals[1]))
                    }
                ]
            },
            "log2(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  ( Binary Logarithm )  ترجع قيمة اللوغارتم الثنائي.\n  log(x, 2) هذه الدالة تعتبر بديل للدالة .\n log2 اللوغاريتم الثنائي في الرياضيات نكتبه ",
                "syntax": "math.log2(x)",
                "params": " x: عبارة عن عدد ليس له نوع محدد.",
                "return": "  x ترجع قيمة اللوغاريتم الثنائي للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x"],
                         "logic": lambda vals: math.log2(safe_eval(vals[0]))
                    }
                ]
            },
            "log10(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  ( Decimal Logarithm )  ترجع قيمة اللوغارتم العشري.\n  log(x, 10) هذه الدالة تعتبر بديل للدالة .\n log10 اللوغاريتم الثنائي في الرياضيات نكتبه ",
                "syntax": "math.log10(x)",
                "params": " x: عبارة عن عدد ليس له نوع محدد.",
                "return": "  x ترجع قيمة اللوغاريتم العشري للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                         "title": "مثال",
                         "inputs": ["x"],
                         "logic": lambda vals: math.log10(safe_eval(vals[0]))
                    }
                ]
            },
            "sin(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (Sine)  ترجع قيمة جيب الزاوية أو الجيب .",
                "syntax": "math.sin(x)",
                "params": " x: قيمة الزاوية بالراديان ",
                "return": "  x رجع قيمة جيب  الزاوية التي نمررها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x with rad "],
                        "logic": lambda vals: math.sin(safe_eval(vals[0]))
                    }
                ]
            },
            "cos(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (coSine )  ترجع قيمة تجيب الزاوية أو التجيب  .",
                "syntax": "math.cos(x)",
                "params": " x: قيمة الزاوية بالراديان.",
                "return": "  x رجع قيمة تجيب  الزاوية التي نمررها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x with rad"],
                        "logic": lambda vals: math.cos(safe_eval(vals[0]))
                    }
                ]
            },
            "tan(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (Tangent  )  ترجع قيمة الظل أو ظل الزاوية أو المماس.",
                "syntax": "math.tan(x)",
                "params": " x: قيمة الزاوية بالراديان.",
                "return": "  x ترجع قيمة ظل  الزاوية التي نمررها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x with rad"],
                        "logic": lambda vals: math.tan(safe_eval(vals[0]))
                    }
                ]
            },
            "asin(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (Arc Sine  )  ترجع قيمة الجيب العكسي أو جيب الزاوية القوسي .",
                "syntax": "math.asin(x)",
                "params": " x: عبارة عن عدد ليس له نوع محدد و يجب أن يكون بين 1- و 1..",
                "return": "  x ترجع قيمة جيب  الزاوية العكسي التي نمررها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x (بين -1 و 1)"],
                        "logic": lambda vals: math.asin(safe_eval(vals[0]))
                    }
                ]
            },
            "acos(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (Arc cos  )  ترجع قيمة جيب التمام العكسي أو جيب تمام الزاوية القوسي  .",
                "syntax": "math.acos(x)",
                "params": " x: عبارة عن عدد ليس له نوع محدد و يجب أن يكون بين 1- و 1..",
                "return": "  x ترجع قيمة جيب تمام الزاوية العكسي التي نمررها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x (بين -1 و 1)"],
                        "logic": lambda vals: math.acos(safe_eval(vals[0]))
                    }
                ]
            },
            "atan(x)": {
                "definition": "x للعدد الذي نمرره لها مكان الباراميتر  (Arc tan  )  ترجع قيمة الظل العكسي أو ظل  الزاوية القوسي .",
                "syntax": "math.atan(x)",
                "params": " x:عبارة عن عدد ليس له نوع محدد .",
                "return": "  x ترجع قيمة ظل الزاوية العكسي التي نمررها مكان الباراميتر \n -pi/2 = - 1.5707963267948966 و  +pi/2 = 1.5707963267948966 يجب ان يكون الناتج بين ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x"],
                        "logic": lambda vals: math.atan(safe_eval(vals[0]))
                    }
                ]
            },
            "degrees(x)": {
                "definition": " .x مكان الباراميتر  ( Radian ) التي نمررها لها كعدد بالراديان (degree) ترجع قيمة الزاوية .\n بمعنى آخر : عندي زاوية بالراديان حولها إلى درجات ",
                "syntax": "math.degrees(x)",
                "params": " x: قيمة الزاوية بالراديان .",
                "return": " float كعدد نوعه  x ترجع قيمة الزاوية للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x with rad "],
                        "logic": lambda vals: math.degrees(safe_eval(vals[0]))
                    }
                ]
            },
            "radians(x)": {
                "definition": " .x مكان الباراميتر  ( degree ) التي نمررها لها كعدد بالدرجات (radian) ترجع قيمة الزاوية .\n بمعنى آخر : عندي زاوية بالدرجات حولها إلى راديان ",
                "syntax": "math.radians(x)",
                "params": " x: قيمة الزاوية بالدرجات .",
                "return": " float كعدد نوعه  x ترجع قيمة الزاوية للعدد الذي نمرره لها مكان الباراميتر ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x with rad "],
                        "logic": lambda vals: math.radians(safe_eval(vals[0]))
                    }
                ]
            },
            "gcd(x,y)": {
                "definition": "  ( Greatest Common Divisor ) ترجع عدد صحيح يمثل القاسم المشترك الأكبر .\n ( x,y ) بين العددين اللذين نمررهما لها مكان الباراميترين ",
                "syntax": "math.gcd(x,y)",
                "params": " x,y: عددان صحيحان  .",
                "return": " ترجع عدد صحيح يمثل القاسم المشترك الأكبر بين .\n x,y العددين اللذين نمررهما لها مكان الباراميترين",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["x العدد الصحيح","y العدد الصحيح"],
                        "logic": lambda vals: math.gcd(int(vals[0]),int(vals[1]))
                    }
                ]
            },
            "inf": {
                "definition": "تمثل قيمة (اللانهاية)في العمليات الرياضية",
                "syntax": "math.inf",
                "params": " لا تأخذ أي باراميتر .",
                "return": "(infinity) قيمة ثابتة تمثل اللانهاية",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [],
                        "logic": lambda vals: math.inf
                    }
                ]
            },
            "nan": {
                "definition": "تمثل قيمة غير معرفة رياضيا",
                "syntax": "math.nan",
                "params": " لا تأخذ أي باراميتر .",
                "return": "قيمة ثابتة تمثل (غير معرف) ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [],
                        "logic": lambda vals: math.nan
                    }
                ]
            },
            "pi": {
                "definition": "تمثل قيمة ثابتة (3.141592653589793) ",
                "syntax": "math.pi",
                "params": " لا تأخذ أي باراميتر .",
                "return": "قيمة ثابتة تمثل (3.141592653589793) ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [],
                        "logic": lambda vals: math.pi
                    }
                ]
            },
            "e": {
                "definition": "تمثل قيمة ثابتة (2.718281828459045) ",
                "syntax": "math.e",
                "params": " لا تأخذ أي باراميتر .",
                "return": "قيمة ثابتة تمثل (2.718281828459045) ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [],
                        "logic": lambda vals: math.e
                    }
                ]
            }
        },
        "cmath module":{
            "phase(z)":{
                "definition": "تعطي زاوية العدد المركب بالنسبة للمحور الحقيقي بالراديان ",
                "syntax": "cmath.phase(z)",
                "params": " z: complex عدد مركب من نوع .",
                "return": " float زاوية العدد المركب بالراديان",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["z : (4+3j : مثل ) عدد مركب "],
                        "logic": lambda vals: cmath.phase(safe_eval(vals[0]))
                    }
                ]
            },
            "polar(z)":{
                "definition": "(المقياس , الزاوية) تحول العدد المركب إلى الشكل القطبي ",
                "syntax": "cmath.polar(z)",
                "params": " z: complex عدد مركب من نوع .",
                "return": " tuble زوج مرتب ( المقياس , الزاوية ) من نوع  ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["z : (4+3j : مثل ) عدد مركب "],
                        "logic": lambda vals: cmath.polar(safe_eval(vals[0]))
                    }
                ]
            }
        },
        "random module":{
            "random()":{
                "definition": "  (1.0 - 0.0) ترجع عدد عشري عشوائي بين .\n 0<= N < 1    أي أن نطاق الأعداد التي ترجعها ",
                "syntax": "random.random()",
                "params": " لا تقبل أي باراميتر .",
                "return": " (1.0 - 0.0) ترجع عدد عشري عشوائي بين  ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [],
                        "logic": lambda _: random.random()
                    }
                ]
            },
            "uniform()":{
                "definition": "  (b - a) ترجع عدد عشري عشوائي بين .\n a<= N <= b    أي أن نطاق الأعداد التي ترجعها ",
                "syntax": "random.uniform()",
                "params": " a: عبارة عن عدد عشري يحدد أقل قيمة ممكن أن ترجعها الدالة.\n b: عبارة عن عدد عشري يحدد القيمة القصوى التي لا يمكن أن ترجعها الدالة.",
                "return": "  ترجع عدد عشري عشوائي بين (b - a) ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["a","b"],
                        "logic": lambda vals: random.uniform(safe_eval(vals[0]),safe_eval(vals[1]))
                    }
                ]
            },
            "randrange(start,stop,step)":{
                "definition": "  stop ترجع عدد صحيح عشوائي بين 0 و القيمة التي نمررها لها مكان الباراميتر .\n start أو ترجع عدد صحيح عشوائي بين القيمة التي نمررها لها مكان الباراميتر \n stop و القيمة التي نمررها لها مكان الباراميتر .\n هذه الدالة يوجد نسختين منها و النسخة الثانية تحتوي على \n باراميتر إختياري مما يعني أنه يمكن استدعاءها بثلاث طرق مختلفة. ",
                "syntax": "الشكل الأول : random.randrange(stop) \n الشكل الثاني : random.randrange(start, stop[, step]) ",
                "params": " stop: عبارة عن عدد صحيح يحدد القيمة التي يجب على الدالة أن ترجع أقل منها.\n start: عبارة عن عدد صحيح يحدد أقل قيمة ممكن أن ترجعها الدالة .\n 0 ستعتبر قيمته تساوي stop و في حال لم يتم تمرير قيمة مكان الباراميتر",
                "return": " 0 ترجع عدد صحيح عشوائي بين \n stop و القيمة التي نمررها لها مكان الباراميتر \nstart  أو ترجع عدد صحيح عشوائي بين القيمة التي نمررها لها مكان الباراميتر \n stop و القيمة التي نمررها لها مكان الباراميتر",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [" stop\n فقط، أو start و stop،\n أو start و stop و step"],
                        "logic": lambda vals: (
                            lambda parts: random.randrange(*[safe_eval(p) for p in parts]))(vals[0].split(","))
                    }
                ]
            },
            "choice(seq)":{
                "definition": " نمررها لها Sequence  ترجع قيمة عشوائية من بين عناصر أي سلسلة .\n (أي سلسلة من الأحرف). السلسلة ممكن أن تكون مصفوفة من الأعداد أو نص عادي.\n فمثلاً، إذا مررنا لها مصفوفة من الأعداد فإنها ترجع عدد عشوائي من ضمن هذه المصفوفة \n و إذا مررنا لها نص فإنها ترجع حرف عشوائي من ضمن هذا النص.",
                "syntax": "random.choice(seq)",
                "params": " seq: عبارة عن كائن  يمثل سلسلة من العناصر مثل مصفوفة أو نص.",
                "return": "  إذا مررنا لها مصفوفة من الأعداد، ترجع عدد عشوائي من ضمن هذه المصفوفة ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": [" نصًا لاختيار حرف، أو قائمة \nأرقام مفصولة بفواصل لاختيار رقم"],
                        "logic": lambda vals: (
                            random.choice(vals[0]) if isinstance(vals[0], str) and "," not in vals[0]
                            else random.choice([safe_eval(v) for v in vals[0].split(",")])
                        )
                    }
                ]
            },
            "shuffle(seq)":{
                "definition": " فتبدل أماكن عناصرها بشكل عشوائي Sequence نمرر لها مصفوفة مكان الباراميتر    .",
                "syntax": "random.shuffle(seq)",
                "params": " seq: عبارة عن مصفوفة ليس لها نوع محدد.",
                "return": " لا ترجع قيمة. ",
                "examples": [
                   {  
                        "title": "مثال",
                        "inputs": ["نصًا ليتم خلط حروفه، أو قائمة أرقام\n مفصولة بفواصل لاختيار رقم عشوائي"],
                        "logic": my_shuffle
                    }
                ]
            }
        }
    },
    "النصوص":{
        "دوال البحث":{
            "count(sub,start,end)":{
                "definition": "sub تبحث في النص الذي قام باستدعائها عن النص الذي نمرره لها مكان الباراميتر .\nثم ترجع عدد المرات التي تم فيها العثور عليه.\n 0في حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع  ",
                "syntax": "str.count(sub.start,end)",
                "params": " sub :و هو النص الذي نريد البحث عنه str عبارة عن نص عادي نوعه.\n start : باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم بدء البحث من عندها.\n •	end :باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم إيقاف البحث قبلها.",
                "return": "sub  ترجع عدد المرات التي تم فيها العثور على النص الذي تم تمرره لها مكان .\n في النص الذي قام باستدعائها .\n 0 وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [ "النص الكامل الذي سيتم البحث فيه",
                                    "السلسلة الفرعية المطلوب عدّها",
                                    "بداية النطاق (اختياري)",
                                    "نهاية النطاق (اختياري)"
                                 ],
                        "logic": count_substring
                    }
                ]
            },
            "find(sub,start,end)":{
                "definition": " تبحث في النص الذي قام باستدعائها عن رقم أول خانةيوجد عندها \n وترجعه sub النص الذي نمرره لها مكان الباراميتر.\n -1 في حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "syntax": "str.find(sub.start,end)",
                "params": " sub :و هو النص الذي نريد البحث عنه str عبارة عن نص عادي نوعه.\n start : باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم بدء البحث من عندها.\n •	end :باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم إيقاف البحث قبلها.",
                "return": "sub ترجع رقم أول خانة في النص الذي قام باستدعائها يوجد عندها النص الذي تم تمرره لها مكان .\n -1 وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [ "النص الكامل الذي سيتم البحث فيه",
                                    "السلسلة الفرعية المطلوب عدّها",
                                    "بداية النطاق (اختياري)",
                                    "نهاية النطاق (اختياري)"
                                 ],
                        "logic": find_substring
                    }
                ]
            },
            "rfind(sub,start,end)":{
                "definition": " تبحث في النص الذي قام باستدعائها عن رقم آخر خانةيوجد عندها \n وترجعه sub النص الذي نمرره لها مكان الباراميتر.\n. رغم أن اسمها يوحي بأنها تبحث (بشكل عكسي )، إلا أن النتيجة التي تُرجعها هي فهرس أول حرف.\n من آخر تطابق، وليس فهرس آخر حرف أو نتيجة سالبة.\n-1 وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع  ",
                "syntax": "str.rfind(sub.start,end)",
                "params": " sub :و هو النص الذي نريد البحث عنه str عبارة عن نص عادي نوعه.\n start : باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم بدء البحث من عندها.\n •	end :باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم إيقاف البحث قبلها.",
                "return": "sub ترجع رقم آخر خانة في النص الذي قام باستدعائها يوجد عندها النص الذي تم تمرره لها مكان .\n -1 وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [ "النص الكامل الذي سيتم البحث فيه",
                                    "السلسلة الفرعية المطلوب عدّها",
                                    "بداية النطاق (اختياري)",
                                    "نهاية النطاق (اختياري)"
                                 ],
                        "logic": rfind_substring
                    }
                ]
            },
            "index(sub,start,end)":{
                "definition": " تبحث في النص الذي قام باستدعائها عن رقم أول خانةيوجد عندها \n وترجعه sub النص الذي نمرره لها مكان الباراميتر.\n ValueError في حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "syntax": "str.index(sub.start,end)",
                "params": " sub :و هو النص الذي نريد البحث عنه str عبارة عن نص عادي نوعه.\n start : باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم بدء البحث من عندها.\n •	end :باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم إيقاف البحث قبلها.",
                "return": "sub ترجع رقم أول خانة في النص الذي قام باستدعائها يوجد عندها النص الذي تم تمرره لها مكان .\n ValueError وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [ "النص الكامل الذي سيتم البحث فيه",
                                    "السلسلة الفرعية المطلوب عدّها",
                                    "بداية النطاق (اختياري)",
                                    "نهاية النطاق (اختياري)"
                                 ],
                        "logic": index_substring
                    }
                ]
            },
            "rindex(sub,start,end)":{
                "definition": " تبحث في النص الذي قام باستدعائها عن رقم آخر خانةيوجد عندها \n وترجعه sub النص الذي نمرره لها مكان الباراميتر.\n. رغم أن اسمها يوحي بأنها تبحث (بشكل عكسي )، إلا أن النتيجة التي تُرجعها هي فهرس أول حرف.\n من آخر تطابق، وليس فهرس آخر حرف أو نتيجة سالبة.\n ValueError وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع  ",
                "syntax": "str.rindex(sub.start,end)",
                "params": " sub :و هو النص الذي نريد البحث عنه str عبارة عن نص عادي نوعه.\n start : باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم بدء البحث من عندها.\n •	end :باراميتر إختياري، مكانه يمكن تمرير رقم الخانة التي سيتم إيقاف البحث قبلها.",
                "return": "sub ترجع رقم آخر خانة في النص الذي قام باستدعائها يوجد عندها النص الذي تم تمرره لها مكان .\n ValueError وفي حال لم يتم العثور على النص المراد البحث عنه فإنها ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [ "النص الكامل الذي سيتم البحث فيه",
                                    "السلسلة الفرعية المطلوب عدّها",
                                    "بداية النطاق (اختياري)",
                                    "نهاية النطاق (اختياري)"
                                 ],
                        "logic": rindex_substring
                    }
                ]
            }
        },
        "دوال التجزيء":{
            "split(sep = None,maxsplit= -1)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مقسمة على شكل مصفوفة نصوص.\n إفتراضياً، كل عنصر في هذه المصفوفة عبارة عن كلمة موجودة في النص.",
                "syntax": "str.split(sep = None,maxsplit= -1)",
                "params": " sep: هو باراميتر إختياري، مكانه يمكن تمرير الحرف أو النص الذي على أساسه \nسيتم تقسيم النص الذي قام باستدعائها.\n maxsplit :هو باراميتر إختياري، مكانه يمكن تمرير عدد العناصر الأقصى في المصفوفة التي سترجعها الدالة.\n في حال لم يتم تحديد النص الذي على أساسه سوق يتم تقسيم النص، فإنه سيتم تقسيمه على أساس المسافات الفارغة مما \n يعني أن كل كلمة سيتم وضعها في عنصر في المصفوفة التي ترجعها الدالة.",
                "return": "ترجع نسخة من النص الذي قام باستدعائها مقسمة على شكل مصفوفة نصوص",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [
                            "النص الكامل الذي سيتم تقسيمه",
                            "الفاصل الذي سيتم استخدامه (اختياري، افتراضي: مسافة)",
                            "العدد الأقصى للتقسيمات (اختياري)"
                        ],
                        "logic": split_substring
                    }
                ]  
            },
            "splitlines(keepends)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مقسمة على شكل مصفوفة نصوص.\n إفتراضياً كل عنصر في هذه المصفوفة عبارة عن سطر موجود في النص.\n  لإبقاء الرموز التي من خلالها عرف مترجم بايثون كيف  true يمكن تمرير القيمة  keepends  مكان الباراميتر \n يفصل الأسطر عن بعضها و من ثم يضيف كل سطر كعنصر في المصفوفة.",
                "syntax": "str.splitlines(keepends)",
                "params": " keepends : لإبقاء الرموز التي من خلالها عرف مترجم بايثون true هو باراميتر إختياري، مكانه يمكن تمرير القيمة \n كيف يفصل الأسطر عن بعضها و من ثم يضيف كل سطر كعنصر في المصفوفة",
                "return": "ترجع نسخة من النص الذي قام باستدعائها مقسمة على شكل مصفوفة نصوص",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص الكامل الذي يحتوي على أسطر متعددة"],
                        "logic": splitlines_substring
                    }
                ]  
            }
        },
        "دوال التبديل":{
            "replace(old,new,count)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع تبديل كل جزئية فيها تتطابق مع النص.\n  new بالنص الذي نمرره لها مكان الباراميتر  old  الذي نمرره لها مكان الباراميتر.\n باختصار تبدل في النص كل قديم بجديد .",
                "syntax": "str.replace(old,new,count)",
                "params": " old : باراميتر نمرر مكانه النص الذي نريد استبداله في النص الأصلي \n new : باراميتر نمرر مكانه النص الذي سيحل مكانه في النسخة التي سترجعها \ncount: هو باراميتر إختياري، مكانه يمكن تمرير رقم أكبر من صفر يمثل أول كم جزئية يتم العثور عليها سيتم تبديلها.",
                "return": " ترجع نسخة معدلة من النص الذي قام باستدعائها.",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": [
                            "النص الأصلي (الكامل)",
                            "النص الذي نريد استبداله",
                            "النص الذي سيحل محله",
                            "عدد الجزئيات المراد استبدالها (اختياري)"
                        ],
                        "logic": replace_substring
                    }
                ]  
            },
            "maketrans(x,y,z)":{
                "definition": "تستخدم لبناء قاموس يمكن إستخدامه لتبديل أحرف النص بأحرف أخرى.\n لتطبيق القاموس الذي تم تجهيزه على النص translate() ملاحظة: من بعدها يجب استخدام الدالة ",
                "syntax": "str.maketrans(x,y,z)",
                "params": "نمرر الحرف أو مجموعة الأحرف المراد تبديلها بأحرف جديدة x مكان الباراميتر \n كما أنه يمكن أن يتم تمرير قاموس\n بشكل مباشر مكانه و فيه يتم تحديد كل ما نريد تبديله و ما الذي سيتم استبداله به \n x هو باراميتر إختياري، مكانه يمكن تمرير الحرف أو مجموعة الأحرف المراد وضعها بدل الأحرف التي تم تمريرها مكان الباراميتر y \n هو باراميتر إختياري، مكانه يمكن تمرير حرف أو مجموعة أحرف ليتم حذفها z .",
                "return": "يمكن إستخدامه لتبديل أحرف النص بأحرف أخرى. table  ترجع قاموس نوعه ",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": ["النص", " الحرف المراد استبداله", "الحرف او الرمز الجديد", "الحرف المراد حذفه"],
                        "logic": translate_substring
                    }
                ] 
            } 
        },
        "دوال المعالجة ":{
            "upper(s)":{
                "definition": "كل أحرفه كبيرة s ترجع نسخة من النص الذي نمرره لها عند استدعائها مكان الباراميتر ",
                "syntax": "str.upper(s)",
                "params": "يجب تمرير نص عادي. s مكان الباراميتر ",
                "return": "ترجع نسخة معدلة من النص الذي يتم تمريره لها.",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": ["النص بأحرف صغيرة"],
                        "logic": lambda vals: str(vals[0]).upper()
                    }
                ]  
            },
            "lower(s)":{
                "definition": "كل أحرفه صغيرة s ترجع نسخة من النص الذي نمرره لها عند استدعائها مكان الباراميتر ",
                "syntax": "str.lower(s)",
                "params": "يجب تمرير نص عادي. s مكان الباراميتر ",
                "return": "ترجع نسخة معدلة من النص الذي يتم تمريره لها.",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": ["النص بأحرف كبيرة"],
                        "logic": lambda vals: str(vals[0]).lower()
                    }
                ]  
            },
            "swapcase(s)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع تحويل الأحرف الكبيرة \n فيها لأحرف صغيرة و الأحرف الصغيرة فيها لأحرف كبيرة ",
                "syntax": "str.swapcase(s)",
                "params": "يجب تمرير نص عادي s مكان الباراميتر ",
                "return": "ترجع نسخة معدلة من النص الذي يتم تمريره لها.",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": [" النص بأحرف كبيرة وصغيرة"],
                        "logic": lambda vals: str(vals[0]).swapcase()
                    }
                ]  
            },
            "capitalize(s)":{
                "definition": "ترجع نسخة من النص الذي نمرره لها عند استدعائها مكان الباراميتر \n  مع تحويل أول حرف فيه لحرف كبير s\n إذاً، هذه الدالة مفيدة في حال أردنا أن نبدأ النص بحرف كبير.. ",
                "syntax": "str.capitalize(s)",
                "params": "يجب تمرير نص عادي s مكان الباراميتر ",
                "return": "ترجع نسخة معدلة من النص الذي يتم تمريره لها.",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": ["النص باحرف صغيرة"],
                        "logic": lambda vals: str(vals[0]).capitalize()
                    }
                ]  
            },
            "title(s)":{
                "definition": "ترجع نسخة من النص الذي نمرره لها عند استدعائها مكان الباراميتر \n  مع تحويل أول حرف من كل كلمة فيه لحرف كبير s\n إذاً، هذه الدالة مفيدة في حال أردنا أن نبدأكل كلمة في النص بحرف كبير.. ",
                "syntax": "str.title(s)",
                "params": "يجب تمرير نص عادي s مكان الباراميتر ",
                "return": "ترجع نسخة معدلة من النص الذي يتم تمريره لها.",
                "examples": [
                    {  
                        "title": "مثال ",
                        "inputs": ["النص باحرف صغيرة"],
                        "logic": lambda vals: str(vals[0]).title()
                    }
                ]  
            },
            "join(iterable)":{
                "definition": "ترجع نص جديد يمثل النص الذي قام باستدعائها مدمجاً بالنص أو   \n iterable بمصفوفة النصوص الذي نمرره لها مكان الباراميتر ",
                "syntax": "str.join(iterable)",
                "params": "نمرر نص عادي أو مصفوفة نصوص  iterable مكان الباراميتر ",
                "return": "تدمج نص بين احرف نص او نص بين عناصر مصفوفة.",
                "examples": [
                    {  
                        "title": "مثال 1: دمج حروف كلمة",
                        "inputs": ["رمز أو حرف", "كلمة"],
                        "logic": smart_join
                    },
                    {
                        "title": "مثال 2: دمج كلمات داخل قائمة",
                        "inputs": ["حرف او رمز", "مصفوفة كلمات"],
                        "logic": smart_join
                    }
                ] 
            },
            "center(width,fillchar)":{
                "definition": "تستخدم لعرض النص الذي قام باستدعائها في وسط السطر في حال لم يتعدى الطول الذي نحدده للسطر",
                "syntax": "str.center(width,fillchar)",
                "params": "width : باراميتر نمرر مكانه عدد يحدد طول السطر , عندها في حال \n كان طول النص أصغر من طول السطر سيتم عرضه في وسطه من خلال \nإضافة مسافات فارغة قبله وبعده \n fillchar: باراميتر اختياري مكانه يمكن تمرير حرف أو رمز يتم وضعه مكان المسافات الفارغة  ",
                "return": "ترجع نسخة من النص و تضيف مسافات فارغة حوله عند الحاجة لجعله يظهر كأنه في المنتصف.",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص", "عدد يمثل طول السطر","رمز يطبع بدال المسافات الفارغة"],
                        "logic": lambda vals: "|" + str(vals[0]).center(int(vals[1]), vals[2] if len(vals) > 2 and vals[2].strip() else " ") + "|"
                    }
                ] 
            },
            "Expandtabs(tabsize)":{
                "definition": " (Tab Spaces) ترجع نسخة من النص الذي قام باستدعائها مع مضاعفة حجم المسافات الفارغة \n '\\ t' التي تم إضافتها في النص بواسطة الرمز. \nإلى 4 مسافات فارغة عند عرضه و لكن في النسخة التي ترجعها '\\ t' عادةً ما يتم تحويل الرمز \n الى 8 مسافات فارغةما لم نقم بتحديد عدد المسافات بنفسنا '\\ t' سيتم تحويل كل رمز  expandtabs() الدالة ",
                "syntax": "str.Expandtabs(tabsize)",
                "params": "يمكن تمرير عدد صحيح يمثل عدد المسافات الفارغة التي سيتم وضعها مكان كل رمز  tabsize  مكان الباراميتر \n موضوع في النص , وفي حال لم يتم تمرير قيمة لهذا الباراميتر فإنه سيحول كل رمز  \\ t  \n إلى 8 مسافات فارغة \\t .",
                "return": "ترجع نسخة معدلة من النص الذي قام باستدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["\\t النص يبدأ بالرمز","tabsize"],
                        "logic": lambda vals: "|" + str(vals[0]).replace("\\t", "\t").expandtabs(int(vals[1]) if vals[1].isdigit() else 8)
                    }
                ] 
            },
            "strip(chars)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع حذف أي مسافة فارغة موجودة في بدايته و نهايته.\n إفتراضياً، هذه الدالة تقوم بحذف المسافات الفارغة الموجودة في أول أو آخر النص.\n لكن إن أردنا مسح أحرف معينة (بدلاً من المسافات الفارغة) في حال وجودها في بداية و نهاية النص.\n chars فيمكننا تمرير هذه الأحرف مكان الباراميتر",
                "syntax": "str.strip(chars)",
                "params": "يمكن تمرير نص لحذفه من النسخة التي سترجعها الدالة في حال كان موجوداً chars مكان الباراميتر \n  في بداية أو نهاية النص الذي قام باستدعائها",
                "return": "ترجع نسخة معدلة من النص الذي قام باستدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص بدايته ونهايته مسافات \n '_' فارغة أو رموز مثل ","الرمز"],
                       "logic": lambda vals: "|" + str(vals[0]).strip(vals[1] if vals[1] else " ") + "|"
                    }
                ] 
            },
            "lstrip(chars)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع حذف أي مسافة فارغة موجودة في بدايته .\n إفتراضياً، هذه الدالة تقوم بحذف المسافات الفارغة الموجودة في أول النص.\n لكن إن أردنا مسح أحرف معينة (بدلاً من المسافات الفارغة) في حال وجودها في بداية النص.\n chars فيمكننا تمرير هذه الأحرف مكان الباراميتر",
                "syntax": "str.lstrip(chars)",
                "params": "يمكن تمرير نص لحذفه من النسخة التي سترجعها الدالة في حال كان موجوداً chars مكان الباراميتر \n  في بدايةالنص الذي قام باستدعائها",
                "return": "ترجع نسخة معدلة من النص الذي قام باستدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص بدايته مسافات \n '_' فارغة أو رموز مثل ","الرمز"],
                       "logic": lambda vals: "|" + str(vals[0]).lstrip(vals[1] if vals[1] else " ") + "|"
                    }
                ] 
            },
            "rstrip(chars)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع حذف أي مسافة فارغة موجودة في نهايته .\n إفتراضياً، هذه الدالة تقوم بحذف المسافات الفارغة الموجودة في آخر النص.\n لكن إن أردنا مسح أحرف معينة (بدلاً من المسافات الفارغة) في حال وجودها في نهاية النص.\n chars فيمكننا تمرير هذه الأحرف مكان الباراميتر",
                "syntax": "str.rstrip(chars)",
                "params": "يمكن تمرير نص لحذفه من النسخة التي سترجعها الدالة في حال كان موجوداً chars مكان الباراميتر \n  في نهايةالنص الذي قام باستدعائها",
                "return": "ترجع نسخة معدلة من النص الذي قام باستدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص نهايته مسافات \n '_' فارغة أو رموز مثل ","الرمز"],
                       "logic": lambda vals: "|" + str(vals[0]).rstrip(vals[1] if vals[1] else " ") + "|"
                    }
                ] 
            },
            "ljust(width,fillchar)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع إضافة مسافات فارغة في نهايته إذا تجاوز عدد أحرفه \n width العدد الذي نمرره مكان الباراميتر \n fillchar  و يمكننا تمرير أي حرف أو رمز مكان الباراميتر\n ليظهر بدلاً من المسافات الفارغة.",
                "syntax": "str.ljust(width,fillchar)",
                "params": "نمرر رقم يحدد طول السطر , وإذا كان طول النص  width  مكان الباراميتر \n أقصر من طول السطر يتم إضافة مسافات فارغة بعده \n هو باراميتر إختياري، مكانه يمكننا تمرير أي حرف ليتم وضعه بدل وضع مسافات فارغة fillchar ",
                "return": "ترجع نسخة من النص الذي قام باستدعائها وقد تضيف بعض المسافات الفارغة أو بعض الأحرف في نهايته بناءً \n على عدد الاحرف الموجودة فيه ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص", "الرمز", "العرض"],
                        "logic": lambda vals: "|" + str(vals[0]).ljust(int(vals[2]), vals[1] if vals[1] else " ") + "|"
                    }
                ] 
            },
            "rjust(width,fillchar)":{
                "definition": "ترجع نسخة من النص الذي قام باستدعائها مع إضافة مسافات فارغة في بدايته إذا تجاوز عدد أحرفه \n width العدد الذي نمرره مكان الباراميتر \n fillchar  و يمكننا تمرير أي حرف أو رمز مكان الباراميتر\n ليظهر بدلاً من المسافات الفارغة.",
                "syntax": "str.rjust(width,fillchar)",
                "params": "نمرر رقم يحدد طول السطر , وإذا كان طول النص  width  مكان الباراميتر \n أقصر من طول السطر يتم إضافة مسافات فارغة قبله \n هو باراميتر إختياري، مكانه يمكننا تمرير أي حرف ليتم وضعه بدل وضع مسافات فارغة fillchar ",
                "return": "ترجع نسخة من النص الذي قام باستدعائها وقد تضيف بعض المسافات الفارغة أو بعض الأحرف في بدايته بناءً \n على عدد الاحرف الموجودة فيه ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص", "الرمز", "العرض"],
                        "logic": lambda vals: "|" + str(vals[0]).rjust(int(vals[2]), vals[1] if vals[1] else " ") + "|"
                    }
                ] 
            }
        },
        "دوال المقارنة ":{
            "startswith(sub,start,end)":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يبدأ بنص معين أم لا. \n tuple يمكننا تمرير نص أو مصفوفة نصوص نوعها  sub مكان الباراميتر \n أو نص أحد عناصره (إن كان عبارة عن مصفوفة) موجود في بداية النص  sub في حال كان نص الباراميتر \n False غير ذلك ترجع True الذي قام باستدعائها سترجع .",
                "syntax": "str.startswith(sub,start,end)",
                "params": "tuple نمرر نص أو مصفوفة نصوص نوعها  sub مكان الباراميتر \n start :باراميتر إختياري، مكانه يمكننا تمرير رقم الخانة التي نريد أن يبدأ البحث عندها. \n end : باراميتر إختياري، مكانه يمكننا تمرير رقم الخانة التي نريد أن يتوقف البحث قبلها.\n sub يمكن تمرير قيم مكانهما فقط في حال تم تمرير نص عادي مكان الباراميتر  end  و start  ",
                "return": " True فإنها ترجع  sub  إذا قمنا بتمرير نص عادي مكان الباراميتر \n False إذا كانت أحرفه تتطابق مع الأحرف الموجودة في بداية النص الذي قام باستدعائها , غير ذلك ترجع \n فإنها : sub مكان الباراميتر  tuple إذا قمنا بتمرير مصفوفة نصوص نوعها \n false في حال وجود نص فيها أحرفه تتطابق مع النص الذي يبدأ به النص الذي قام باستدعائها , غير ذلك ترجع  true ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص", " البادئة مع | اذا مصفوفة", "من (start)", "إلى (end)"],
                        "logic": lambda vals: check_start(
                            str(vals[0]),
                            tuple(filter(None, vals[1].split("|"))) if "|" in vals[1] else vals[1],
                            int(vals[2]) if vals[2] else None,
                            int(vals[3]) if vals[3] else None
                        )
                    }
                ] 
            },
            "endswith(sub,start,end)":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها ينتهي بنص معين أم لا. \n tuple يمكننا تمرير نص أو مصفوفة نصوص نوعها  sub مكان الباراميتر \n أو نص أحد عناصره (إن كان عبارة عن مصفوفة) موجود في نهاية النص  sub في حال كان نص الباراميتر \n False غير ذلك ترجع True الذي قام باستدعائها سترجع .",
                "syntax": "str.endswith(sub,start,end)",
                "params": "tuple نمرر نص أو مصفوفة نصوص نوعها  sub مكان الباراميتر \n start :باراميتر إختياري، مكانه يمكننا تمرير رقم الخانة التي نريد أن يبدأ البحث عندها. \n end : باراميتر إختياري، مكانه يمكننا تمرير رقم الخانة التي نريد أن يتوقف البحث قبلها.\n sub يمكن تمرير قيم مكانهما فقط في حال تم تمرير نص عادي مكان الباراميتر  end  و start  ",
                "return": " True فإنها ترجع  sub  إذا قمنا بتمرير نص عادي مكان الباراميتر \n False إذا كانت أحرفه تتطابق مع الأحرف الموجودة في نهاية النص الذي قام باستدعائها , غير ذلك ترجع \n فإنها : sub مكان الباراميتر  tuple إذا قمنا بتمرير مصفوفة نصوص نوعها \n false في حال وجود نص فيها أحرفه تتطابق مع النص الذي ينتهي به النص الذي قام باستدعائها , غير ذلك ترجع  true ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص", " البادئة مع | اذا مصفوفة", "من (start)", "إلى (end)"],
                        "logic": lambda vals: check_end(
                            str(vals[0]),
                            tuple(filter(None, vals[1].split("|"))) if "|" in vals[1] else vals[1],
                            int(vals[2]) if vals[2] else None,
                            int(vals[3]) if vals[3] else None
                        )
                    }
                ] 
            },
            "isalpha()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.isalpha()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isalpha()
                    }
                ] 
            },
            "isnumeric()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أرقـام فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.isnumeric()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أرقـام فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isnumeric()
                    }
                ] 
            },
            "isdigit()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أرقـام فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .\n  (1/2) ملاحظة: هذه الدالة لا تعتبر الرموز التي تمثل قيم رقمية مثل الرمز \n isnumeric كرقم، و هذا هو الفرق بينها و بين الدالة ",
                "syntax": "str.isdigit()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أرقـام فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isdigit()
                    }
                ] 
            },
            "isalnum()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية و أرقـام فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.isalnum()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية و أرقـام فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isalnum()
                    }
                ] 
            },
            "islower()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية صغيرة فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.islower()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية صغيرة فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).islower()
                    }
                ] 
            },
            "isupper()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية كبيرة فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.isupper()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على أحرف أبجدية كبيرة فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isupper()
                    }
                ] 
            },
            "istitle()":{
                "definition": "تتستخدم لمعرفة ما إذا كان أول حرف من كل كلمة في النص الذي قام باستدعائها هو حرف كبير  أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.istitle()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان أول حرف من كل كلمة في النص الذي قام باستدعائها هو حرف كبير فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).istitle()
                    }
                ] 
            },
            "isspace()":{
                "definition": "تستخدم لمعرفة ما إذا كان النص الذي قام باستدعائها يحتوي على مسافة فارغة أو عدة مسافات فارغة فقط أم لا. \n False إن كان كذلك غير ذلك ترجع  True ترجع .",
                "syntax": "str.isspace()",
                "params": "لا تقبل اي باراميتر",
                "return": " true إذا كان النص الذي قام باستدعائها يحتوي على مسافة فارغة أو عدة مسافات فارغة فقط فإنها ترجع \n False غير ذلك ترجع ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["النص"],
                        "logic": lambda vals: str(vals[0]).isspace()    # لا تقبل "|" لأن | في بايثون هو عامل منطقي (bitwise OR)
                    }
                ] 
            }
        }
    },
    "list الكلاس":{
        "دوال الإضافة":{
            "append(obj)":{
                "definition": "الذي قام باستدعائهاlistتستخدم لإضافة عنصر جديد في آخر الـ",
                "syntax": "list.append(obj)",
                "params": "listنمرر الكائن الذي نريد إضافته في آخر الـ obj مكان الباراميتر",
                "return": "  لا ترجع قيمة ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["القائمة", "العنصر"],
                        "logic": lambda vals: (
                            format_list(result) if isinstance((result := smart_add(vals[0], vals[1], mode="append")), list)
                            else result
                        )
                    }
                ]                 
            },
            "extend(iterable)":{
                "definition": "الذي قام باستدعائهاlistتستخدم لإضافة مصفوفة من أي نوع في آخر الـ",
                "syntax": "list.extend(iterable)",
                "params": "listنمرر كائن يمثل المصفوفة  التي نريد إضافتها في آخر الـ iterable مكان الباراميتر",
                "return": "  لا ترجع قيمة ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist1", "alist2"],
                        "logic": lambda vals: (
                             format_list(result) if isinstance((result := smart_add(vals[0], vals[1], mode="extend")), list)
                             else result
                        )
                    }
                ]                 
            },
            "insert(index,obj)":{
                "definition": "الذي قام باستدعائهاlistتستخدم لإضافة عنصر جديد في مكان محدد في الـ",
                "syntax": "list.insert(index,obj)",
                "params": " نمرر رقم الفهرس الذي سيضاف عنده الكائن الذي يتم تمريره مكان  index مكان الباراميتر \n  obj الباراميتر ",
                "return": "  لا ترجع قيمة ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist","رقم الفهرس", "الكائن"],
                        "logic": lambda vals: (
                            format_list(result) if isinstance((result := smart_add(vals[0], vals[2], mode="insert", index=int(vals[1]))), list)
                            else result
                        )
                    }
                ]                 
            }
        },
        "دوال الحذف":{
            "pop(index)":{
                "definition": "الذي قام باستدعائها أو لحذف آخر عنصر موجود فيه list تستخدم لحذف عنصر محدد من الـ",
                "syntax": "list.pop(index)",
                "params": "index : list هو باراميتر اختياري نمرر مكانه رقم الفهرس الذي نريد الحصول على قيمته ومن ثم حذفه من ال\n و من ثم حذفه. list في حال لم يتم تحديد رقم فهرس العنصر، فإنه سيتم إرجاع قيمة آخر عنصر موجود في الـ",
                "return": " list ترجع العنصر الذي تم حذفه من الــ ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist","رقم الفهرس"],
                        "logic": lambda vals: (
                            result := list_action(vals[0], mode="pop", index=vals[1] if vals[1] else None)
                        )
                    }
                ]                 
            },
            "remove(index)":{
                "definition": " index الذي قام باستدعائها يملك نفس القيمة التي نمررها لها مكان البارميتر listتستخدم لحذف أول عنصر يتم إيجاده في ال\n ValueError و في حال لم يتم العثور على القيمة المراد حذفها ترمي الإستثناء ",
                "syntax": "list.remove(index)",
                "params": "list نمرر القيمة التي نريد حذفها من  index مكان البارميتر ",
                "return": " لا ترجع قيمة ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist", "القيمة المراد حذفها"],
                        "logic": lambda vals: list_action(vals[0], mode="remove", value=vals[1])
                    }
                ]                 
            },
            "clear()":{
                "definition": "الذي قام باستدعائها list تستخدم لحذف جميع عناصر",
                "syntax": "list.clear()",
                "params": "لا تقبل أي باراميتر",
                "return": " لا ترجع قيمة ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist"],
                        "logic": lambda vals: list_action(vals[0], mode="clear")
                    }
                ]                 
            }
        },
        "دوال البحث":{
            "count(x)":{
                "definition": " الذي قام باستدعائهاعن قيمة معينة list تستخدم للبحث في \n x ترجع عدد صحيح يمثل كم مرة تم إيجاد عنصر عنده نفس القيمة التي مررناها لها مكان البارميتر ",
                "syntax": "list.count(x)",
                "params": "list نمرر الكائن أو القيمة التي نريد البحث عنها في xمكان الباراميتر",
                "return": "الذي قام باستدعائها  listترجع عدد صحيح يمثل كم مرة تم إيجاد عنصر في الــ \n x عنده نفس القيمة التي مررناها لها مكان البارميتر",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist","الكائن الذي نريد البحث عنه"],
                        "logic": lambda vals: strict_type("list", vals[0]).count(vals[1]) if isinstance(strict_type("list", vals[0]), list) else strict_type("list", vals[0])
                    }
                ]    
            },
            "index(x,start,end)":{
                "definition": "x الذي قام باستدعائهاعن رقم فهرس أول عنصر يملك القيمة التي نمرره لها مكان الباراميتر list تستخدم للبحث في \n ValueError  و ترجعه.  في حال لم يتم العثور على القيمة المراد معرفة مكانها ترمي الإستثناء",
                "syntax": "list.index(x,start,end)",
                "params": "x:القيمة التي نريد البحث عنها \n start: باراميتر إختياري، مكانه يمكننا تمرير رقم فهرس العنصر الذي نريد بدء البحث من عنده \n end : باراميتر إختياري، مكانه يمكننا تمرير رقم فهرس العنصر الذي نريد إيقاف البحث قبله.",
                "return": "x ترجع رقم فهرس أول عنصر يملك القيمة التي نمررها لها مكان الباراميتر ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist","x","start","end"],
                        "logic": lambda vals: try_index(
                            vals[0],
                            vals[1],
                            vals[2] if len(vals) > 2 else "",
                            vals[3] if len(vals) > 3 else ""
                        )
                    }
                ]    
            }
        },
        "دالة النسخ":{
            "copy()":{
                "definition": "الذي قام باستدعائها list ترجع نسخة من ",
                "syntax": "list.copy()",
                "params": "لا تقبل أي باراميتر",
                "return": "الذي قام باستدعائها list ترجع نسخة من ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist"],
                        "logic": lambda vals: (
                            f"alist = {format_list(eval(vals[0]))}\nalistcopy = {format_list(eval(vals[0]).copy())}"
                        )
                    }
                ]    
            }
        },
        "دوال الترتيب":{
            "sort(reverse=false)":{
                "definition": "الذي قام باستدعائها بشكل تصاعدي أو تنازلي.  list تستخدم لترتيب عناصر ال \n في حال لم نقم بتمرير أي قيمة لها عند استدعائها فإنها ستقوم بترتيب العناصر بشكل تصاعدي",
                "syntax": "list.sort(reverse)",
                "params": "reverse: True هو باراميتر اختياري مكانه يمكننا تمرير القيمة \n لجعل عناصرالكلاس تترتب بشكل تنازلي . ",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist",'Reverse'],
                        "logic": lambda vals: sort_list(vals[0], vals[1])
                    }
                ]    
            },
            "reverse()":{
                "definition": "تستخدم لعكس ترتيب عناصر الكلاس الذي قام باستدعائها.",
                "syntax": "list.reverse()",
                "params": "لا تقبل اي باراميتر",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["alist"],
                        "logic": lambda vals: reverse_list(vals[0])
                    }
                ]    
            }
        },
        "list دوال جاهزة للتعامل مع الكلاس ":{
            "len(list)":{
                "definition": " ترجع عدد صحيح يمثل عدد عناصر الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "len(list)",
                "params": "نمرر المصفوفة التي نريد الحصول على عدد عناصرها . list مكان الباراميتر ",
                "return": "ترجع عدد صحيح يمثل عدد عناصر المصفوفة التي نمررها لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["list"],
                        "logic": lambda vals: len(strict_type("list", vals[0])) if isinstance(strict_type("list", vals[0]), list) else strict_type("list", vals[0])
                    }
                ]    
            },
            "min(list)":{
                "definition": " ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "min(list)",
                "params": "نمرر المصفوفة التي نريد الحصول على أصغر قيمة فيها . list مكان الباراميتر ",
                "return": "ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["list"],
                        "logic": lambda vals: min(strict_type("list", vals[0])) if isinstance(strict_type("list", vals[0]), list) else strict_type("list", vals[0])
                    }
                ]    
            },
            "max(list)":{
                "definition": " ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "max(list)",
                "params": "نمرر المصفوفة التي نريد الحصول على أكبر قيمة فيها . list مكان الباراميتر ",
                "return": "ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["list"],
                        "logic": lambda vals: max(strict_type("list", vals[0])) if isinstance(strict_type("list", vals[0]), list) else strict_type("list", vals[0])
                    }
                ]    
            },
            "list(sequence)":{
                "definition": "مثل السلاسل النصية، المجموعات، القواميس، أو حتى الكائنات المخصصة (iterable) تُستخدم لتحويل أي كائن قابل للتكرار \n (list) إلى كائن من نوع قائمة",
                "syntax": "list(sequence)",
                "params": "نمرر كائن يحتوي مجموعة عناصر  . sequence مكان الباراميتر ",
                "return": "list ترجع نسخة من أي كائن يحتوي مجموعة عناصر نمرره لها عند إستدعائها ككائن من الكلاس",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["sequence"],
                        "logic": lambda vals: format_list(list(eval(vals[0])))
                    }
                ]    
            }
        }
    },
    "tuple دوال الكلاس":{
        "دوال البحث":{
            "count(x)":{
                "definition": " الذي قام باستدعائهاعن قيمة معينة tuple تستخدم للبحث في \n x ترجع عدد صحيح يمثل كم مرة تم إيجاد عنصر عنده نفس القيمة التي مررناها لها مكان البارميتر ",
                "syntax": "tuple.count(x)",
                "params": "tuple نمرر الكائن أو القيمة التي نريد البحث عنها في xمكان الباراميتر",
                "return": "الذي قام باستدعائها tuple ترجع عدد صحيح يمثل كم مرة تم إيجاد عنصر في الــ \n x عنده نفس القيمة التي مررناها لها مكان البارميتر",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["atuple","الكائن الذي نريد البحث عنه"],
                        "logic": lambda vals: strict_type("tuple", vals[0]).count(auto_cast(vals[1]))
                           if isinstance(strict_type("tuple", vals[0]), tuple)
                           else strict_type("tuple", vals[0])
                    }
                ]    
            },
            "index(x,start,end)":{
                "definition": "x الذي قام باستدعائهاعن رقم فهرس أول عنصر يملك القيمة التي نمرره لها مكان الباراميتر tuple تستخدم للبحث في \n ValueError  و ترجعه.  في حال لم يتم العثور على القيمة المراد معرفة مكانها ترمي الإستثناء",
                "syntax": "tuple.index(x,start,end)",
                "params": "x:القيمة التي نريد البحث عنها \n start: باراميتر إختياري، مكانه يمكننا تمرير رقم فهرس العنصر الذي نريد بدء البحث من عنده \n end : باراميتر إختياري، مكانه يمكننا تمرير رقم فهرس العنصر الذي نريد إيقاف البحث قبله.",
                "return": "x ترجع رقم فهرس أول عنصر يملك القيمة التي نمررها لها مكان الباراميتر ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["atuple","x","start","end"],
                        "logic": lambda vals: (
                            (lambda obj, elem:
                                elem if isinstance(elem, str) and elem.startswith("❌")
                                else (obj.add(elem) or obj)
                            )(set_strict(vals[0]), auto_cast_safe(vals[1]))
                            if isinstance(set_strict(vals[0]), set)
                            else set_strict(vals[0])
                        )
                    }
                ]    
            }
        },
        "tuple دوال جاهزة للتعامل مع الكلاس ":{
            "len(tuple)":{
                "definition": " ترجع عدد صحيح يمثل عدد عناصر الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "len(tuple)",
                "params": "نمرر المصفوفة التي نريد الحصول على عدد عناصرها . tuple مكان الباراميتر ",
                "return": "ترجع عدد صحيح يمثل عدد عناصر المصفوفة التي نمررها لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["tuple"],
                        "logic": lambda vals: len(strict_type("tuple", vals[0])) 
                            if isinstance(strict_type("tuple", vals[0]), tuple) 
                            else strict_type("tuple", vals[0])
                    }
                ]    
            },
            "min(tuple)":{
                "definition": " ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "min(tuple)",
                "params": "نمرر المصفوفة التي نريد الحصول على أصغر قيمة فيها . tuple مكان الباراميتر ",
                "return": "ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["tuple"],
                        "logic": lambda vals: min(strict_type("tuple", vals[0])) 
                            if isinstance(strict_type("tuple", vals[0]), tuple) 
                            else strict_type("tuple", vals[0])
                    }
                ]    
            },
            "max(tuple)":{
                "definition": " ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "max(tuple)",
                "params": "نمرر المصفوفة التي نريد الحصول على أكبر قيمة فيها . tuple مكان الباراميتر ",
                "return": "ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["tuple"],
                        "logic": lambda vals: max(strict_type("tuple", vals[0])) 
                            if isinstance(strict_type("tuple", vals[0]), tuple) 
                            else strict_type("tuple", vals[0])
                    }
                ]    
            },
            "tuple(sequence)":{
                "definition": "مثل السلاسل النصية، المجموعات، القواميس، أو حتى الكائنات المخصصة (iterable) تُستخدم لتحويل أي كائن قابل للتكرار \n (tuple) إلى كائن من نوع قائمة",
                "syntax": "tuple(sequence)",
                "params": "نمرر كائن يحتوي مجموعة عناصر  . sequence مكان الباراميتر ",
                "return": "tuple ترجع نسخة من أي كائن يحتوي مجموعة عناصر نمرره لها عند إستدعائها ككائن من الكلاس",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["sequence"],
                        "logic": lambda vals: tuple(eval(vals[0]))
                    }
                ]    
            }
        }
    },
    "set دوال الكلاس ":{
        "دوال عامة":{
            "add(elem)":{
                "definition": "الذي قام باستدعائها set تستخدم لإضافة عنصر جديد في الـ",
                "syntax": "set.add(elem)",
                "params": "set نمرر القيمة التي نريد اضافتها كعنصر جديد في الـ elem مكان الباراميتر ",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس","العنصر المراد إضافته"],
                        "logic": lambda vals: (
                            (lambda obj, elem:
                                elem if isinstance(elem, str) and elem.startswith("❌")
                                else (obj.add(elem) or obj)
                            )(set_strict(vals[0]), parse_input(vals[1]))
                            if isinstance(set_strict(vals[0]), set)
                            else set_strict(vals[0])
                        )
                    }
                ]    
            },
            "discard(elem)":{
                "definition": "الذي قام باستدعائها set تستخدم لحذف عنصر محدد في الـ",
                "syntax": "set.discard(elem)",
                "params": "set نمرر قيمة العنصر الذي نريد حذفه من الـ elem مكان الباراميتر ",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس","العنصر المراد حذفـه"],
                        "logic": lambda vals: (
                            (lambda obj, elem:
                                elem if isinstance(elem, str) and elem.startswith("❌")
                                else (obj.discard(elem) or obj)
                            )(set_strict(vals[0]), parse_input(vals[1]))
                            if isinstance(set_strict(vals[0]), set)
                            else set_strict(vals[0])
                        )
                    }
                ]    
            },
            "remove(elem)":{
                "definition": "الذي قام باستدعائها set تستخدم لحذف عنصر محدد في الـ \n setفي حال لم يتم إيجاد عنصر في الـ KeyError  أنها ترمي الإستثناء  discard ملاحظة: الفرق بينها و بين الدالة \n elem يملك نفس قيمة الكائن الذي مررناه مكان الباراميتر ",
                "syntax": "set.remove(elem)",
                "params": "set نمرر قيمة العنصر الذي نريد حذفه من الـ elem مكان الباراميتر ",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس","العنصر المراد حذفـه"],
                        "logic": lambda vals: (
                            (lambda obj, elem:
                                elem if isinstance(elem, str) and elem.startswith("❌")
                                else (obj.remove(elem) or obj) if elem in obj
                                else "❌ KeyError "
                            )(set_strict(vals[0]), parse_input(vals[1]))
                            if isinstance(set_strict(vals[0]), set)
                            else set_strict(vals[0])
                        )
                    }
                ]    
            },
            "clear()":{
                "definition": "الذي قام باستدعائها set تستخدم لحذف جميع عناصر الـ ",
                "syntax": "set.clear()",
                "params": "لا تقبل اي باراميتر",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس"],
                        "logic": lambda vals: ((lambda obj: obj.clear() or obj)(set_strict(vals[0])) if isinstance(set_strict(vals[0]), set) else set_strict(vals[0]))
                    }
                ]    
            },
            "pop()":{
                "definition": "الذي قام باستدعائها و من بعدها يتم حذفه منه. setتستخدم لإرجاع قيمة عنصر يتم إختياره بشكل عشوائي من الـ",
                "syntax": "set.pop()",
                "params": "لا تقبل اي باراميتر",
                "return": " set ترجع قيمة العنصر الذي تم حذفه من",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس"],
                        "logic": lambda vals: (
                            (lambda obj:
                            "❌ خطأ: المجموعة فارغة" if len(obj) == 0
                            else (lambda removed: f"the del element : {removed}\n{obj}")(obj.pop())
                            )(set_strict(vals[0]))
                            if isinstance(set_strict(vals[0]), set)
                            else set_strict(vals[0])
                        )
                    }
                ]    
            },
            "copy()":{
                "definition": "ترجع نسخة من الكلاس الذي قام باستدعائها.",
                "syntax": "set.copy()",
                "params": "لا تقبل اي باراميتر",
                "return": "ترجع نسخة من الكلاس الذي قام باستدعائها.",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set الكلاس"],
                        "logic": lambda vals: ((lambda obj: obj.copy() or obj)(set_strict(vals[0])) if isinstance(set_strict(vals[0]), set) else set_strict(vals[0]))
                    }
                ]    
            },
            "difference(*set)": {
                "definition": "*sets نمرره لها مكان الباراميتر set الذي قام باستدعائها والغير موجودة في كل  set جديد يحتوي على عناصر  setتنتج \n  ( لا تغير المجموعة الأصلية )",
                "syntax": "set.difference(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": " *sets نمرره لها مكان الباراميتر  set الذي قام باستدعائها والغير موجودة في كل  set جديد يحتوي على عناصر set ترجع",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: ((lambda obj, others:(lambda result:f"النتيجة: {result}\n" f"الصيغة المستخدمة: set.difference(" +
                            ", ".join([f"set{i+1}" for i in range(len(others))]) + ")")(obj.difference(*others)))(set_strict(vals[0]), [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)])
                            if isinstance(set_strict(vals[0]), set)else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل")
                    }
                ]
            },
            "difference_update(*set)": {
                "definition": "*sets نمرره لها مكان الباراميتر  set الذي قام باستدعائها والغير موجودة في كل  setجديد يحتوي على عناصر  set إلى set تغير \n  (  تغير المجموعة الأصلية مباشرة)",
                "syntax": "set.difference_update(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": "لا ترجع قيمة",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: (
                            (lambda obj, others:
                                (obj.difference_update(*others) or
                                 f"النتيجة بعد التعديل: {obj}\n"
                                 f"الصيغة المستخدمة: set.difference_update(" +
                                ", ".join([f"set{i+1}" for i in range(len(others))]) + ")")
                            )(
                                set_strict(vals[0]),
                                [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)]
                            )
                            if isinstance(set_strict(vals[0]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل"
                        )
                    }
                ]
            },
            "intersection(*sets)": {
                "definition": "*sets نمرره لها مكان الباراميتر set الذي قام باستدعائهاو في كل  set جديد يحتوي على عناصر  setتنتج \n  ( لا تغير المجموعة الأصلية )",
                "syntax": "set.intersection(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": " *sets نمرره لها مكان الباراميتر  set الذي قام باستدعائها و في كل  set جديد يحتوي على عناصر set ترجع",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: ((lambda obj, others:(lambda result:f"النتيجة: {result}\n" f"الصيغة المستخدمة: set.intersection(" +
                            ", ".join([f"set{i+1}" for i in range(len(others))]) + ")")(obj.intersection(*others)))(set_strict(vals[0]), [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)])
                            if isinstance(set_strict(vals[0]), set)else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل")
                    }
                ]
            },
            "intersection_update(*set)": {
                "definition": "*sets نمرره لها مكان الباراميتر  set الذي قام باستدعائها و في كل  setجديد يحتوي على عناصر  set إلى set تغير \n  (  تغير المجموعة الأصلية مباشرة)",
                "syntax": "set.intersection_update(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": "لا ترجع قيمة",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: (
                            (lambda obj, others:
                                (obj.intersection_update(*others) or
                                 f"النتيجة بعد التعديل: {obj}\n"
                                 f"الصيغة المستخدمة: set.intersection_update(" +
                                ", ".join([f"set{i+2}" for i in range(len(others))]) + ")")
                            )(
                                set_strict(vals[0]),
                                [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)]
                            )
                            if isinstance(set_strict(vals[0]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل"
                        )
                    }
                ]
            },
            "symmetric_difference(anotherset) ": {
                "definition": "*anotherset نمرره لها مكان الباراميتر set الذي قام باستدعائهاأو في set جديد يحتوي على عناصر  setتنتج \n  لكن ليست موجودة في الاثنين معا.. لا تقبل المقارنة مع اكثر من كائن واحد \n ( لا تغير المجموعة الأصلية )",
                "syntax": "set.symmetric_difference(anotherset) ",
                "params": "*anotherset :  set باراميتر مكانه نمرر كائن نوعه",
                "return": " *anotherset نمرره لها مكان الباراميتر  set الذي قام باستدعائها أو في set جديد يحتوي على عناصر set ترجع \n  لكن ليست موجودة في الاثنين معا ",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1"],
                        "logic": lambda vals: (
                            (lambda obj, other:
                                f"النتيجة: {obj.symmetric_difference(other)}\n"
                                f"الصيغة المستخدمة: {vals[0]}.symmetric_difference({vals[1]})"
                            )(set_strict(vals[0]), set_strict(vals[1]))
                            if len(vals) > 1 and isinstance(set_strict(vals[0]), set) and isinstance(set_strict(vals[1]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أساسية ومجموعة إضافية واحدة فقط"
                        )
                    }
                ]
            },
            "symmetric_difference_update(anotherset)": {
                "definition": "*anotherset نمرره لها مكان الباراميتر  set الذي قام باستدعائها أو في   setجديد يحتوي على عناصر  set إلى set تغير \n . لكن ليست موجودة في الاثنين معا.. لا تقبل المقارنة مع اكثر من كائن واحد .\n (  تغير المجموعة الأصلية مباشرة)",
                "syntax": "set.symmetric_difference_update(anotherset)",
                "params": "*anotherset :set باراميتر مكانه نمرر كائن نوعه",
                "return": "لا ترجع قيمة",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1"],
                        "logic": lambda vals: (
                            (lambda obj, other:
                                (obj.symmetric_difference_update(other) or
                                f"النتيجة بعد التعديل: {obj}\n"
                                f"الصيغة المستخدمة: {vals[0]}.symmetric_difference_update({vals[1]})")
                            )(set_strict(vals[0]), set_strict(vals[1]))
                            if len(vals) > 1 and isinstance(set_strict(vals[0]), set) and isinstance(set_strict(vals[1]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أساسية ومجموعة إضافية واحدة فقط"
                        )
                    }
                ]
            },
            "union(*sets)": {
                "definition": "*sets نمرره لها مكان الباراميتر set الذي قام باستدعائهاو في كلset جديد يحتوي على عناصر  setتنتج \n أي يحتوي جميع عناصر المجموعات دون تكرار.  \n ( لا تغير المجموعة الأصلية )",
                "syntax": "set.union(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": "ترجع مجموعة جديدة  تحوي جميع عناصر المجموعات بدون تكرار .",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: ((lambda obj, others:(lambda result:f"النتيجة: {result}\n" f"الصيغة المستخدمة: set.union(" +
                            ", ".join([f"set{i+1}" for i in range(len(others))]) + ")")(obj.union(*others)))(set_strict(vals[0]), [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)])
                            if isinstance(set_strict(vals[0]), set)else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل")
                    }
                ]
            },
            "update(*set)": {
                "definition": "*sets نمرره لها مكان الباراميتر  set الذي قام باستدعائها و في كل  setجديد يحتوي على عناصر  set إلى set تغير \n أي يحتوي جميع عناصر المجموعات دون تكرار.\n (  تغير المجموعة الأصلية مباشرة)",
                "syntax": "set.update(*sets)",
                "params": "*sets : أو أكثر مع الإشارة الى أنه يجب وضع فاصلة بينهم  set باراميتر مكانه نمرر كائن نوعه",
                "return": "لا ترجع قيمة",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1","set2"],
                        "logic": lambda vals: (
                            (lambda obj, others:
                                (obj.update(*others) or
                                 f"النتيجة بعد التعديل: {obj}\n"
                                 f"الصيغة المستخدمة: set.update(" +
                                ", ".join([f"set{i+2}" for i in range(len(others))]) + ")")
                            )(
                                set_strict(vals[0]),
                                [s for s in (set_strict(v) for v in vals[1:] if v not in (None, "")) if isinstance(s, set)]
                            )
                            if isinstance(set_strict(vals[0]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أصلية واحدة على الأقل"
                        )
                    }
                ]
            },
            "isdisjoint(anotherset) ": {
                "definition": "anotherset الذي نمرره لها مكان الباراميتر  set الذي قام باستدعائها مع قيم الـ set تقارن قيم ",
                "syntax": "set.isdisjoint(anotherset) ",
                "params": "*anotherset : الذي قام باستدعائها set الذي سيتم مقارنة قيمه مع قيم الـ set باراميتر مكانه نمرر كائن نوعه",
                "return": "إن لم يكونا كذلك False إذا كانت جميع قيمهما مختلفة، و ترجع  True يرجع",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1"],
                        "logic": lambda vals: (
                            (lambda obj, other:
                                f"النتيجة: {obj.isdisjoint(other)}\n"
                                f"الصيغة المستخدمة: {vals[0]}.isdisjoint({vals[1]})"
                            )(set_strict(vals[0]), set_strict(vals[1]))
                            if len(vals) > 1 and isinstance(set_strict(vals[0]), set) and isinstance(set_strict(vals[1]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أساسية ومجموعة إضافية واحدة فقط"
                        )
                    }
                ]
            },
            "issuperset(anotherset) ": {
                "definition": "anotherset الذي نمرره لها مكان الباراميتر  set الذي قام باستدعائها مع قيم الـ set تقارن قيم ",
                "syntax": "set.issuperset(anotherset) ",
                "params": "*anotherset : الذي قام باستدعائها set الذي سيتم مقارنة قيمه مع قيم الـ set باراميتر مكانه نمرر كائن نوعه",
                "return": " set موجودة في الـ anotherset الذي نمرره لها مكان الباراميتر  set ذا كانت جميع قيم الـ   True يرجع \n False الذي قام باستدعائها، غير ذلك ترجع ",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1"],
                        "logic": lambda vals: (
                            (lambda obj, other:
                                f"النتيجة: {obj.issuperset(other)}\n"
                                f"الصيغة المستخدمة: {vals[0]}.issuperset({vals[1]})"
                            )(set_strict(vals[0]), set_strict(vals[1]))
                            if len(vals) > 1 and isinstance(set_strict(vals[0]), set) and isinstance(set_strict(vals[1]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أساسية ومجموعة إضافية واحدة فقط"
                        )
                    }
                ]
            },
            "issubset(anotherset) ": {
                "definition": "anotherset الذي نمرره لها مكان الباراميتر  set الذي قام باستدعائها مع قيم الـ set تقارن قيم ",
                "syntax": "set.issubset(anotherset) ",
                "params": "*anotherset : الذي قام باستدعائها set الذي سيتم مقارنة قيمه مع قيم الـ set باراميتر مكانه نمرر كائن نوعه",
                "return": "anotherset الذي قام باستدعائها موجودة في set ذا كانت جميع قيم الـ   True يرجع \n False  غير ذلك ترجع ",
                "examples": [
                    {
                        "title": "مثال",
                        "inputs": ["aSet", "Set1"],
                        "logic": lambda vals: (
                            (lambda obj, other:
                                f"النتيجة: {obj.issubset(other)}\n"
                                f"الصيغة المستخدمة: {vals[0]}.issubset({vals[1]})"
                            )(set_strict(vals[0]), set_strict(vals[1]))
                            if len(vals) > 1 and isinstance(set_strict(vals[0]), set) and isinstance(set_strict(vals[1]), set)
                            else "❌ خطأ: يجب إدخال مجموعة أساسية ومجموعة إضافية واحدة فقط"
                        )
                    }
                ]
            }
        },
        "set دوال جاهزة للتعامل مع الكلاس ":{
            "len(set)":{
                "definition": " ترجع عدد صحيح يمثل عدد عناصر الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "len(set)",
                "params": "نمرر المصفوفة التي نريد الحصول على عدد عناصرها . set مكان الباراميتر ",
                "return": "ترجع عدد صحيح يمثل عدد عناصر المصفوفة التي نمررها لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set"],
                        "logic": lambda vals: len(strict_type("set", vals[0])) 
                            if isinstance(strict_type("set", vals[0]), set) 
                            else strict_type("set", vals[0])
                    }
                ]    
            },
            "min(set)":{
                "definition": " ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "min(set)",
                "params": "نمرر المصفوفة التي نريد الحصول على أصغر قيمة فيها . set مكان الباراميتر ",
                "return": "ترجع أصغر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set"],
                        "logic": lambda vals: min(strict_type("set", vals[0])) 
                            if isinstance(strict_type("set", vals[0]), set) 
                            else strict_type("set", vals[0])
                    }
                ]    
            },
            "max(set)":{
                "definition": " ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند إستدعائها.",
                "syntax": "max(set)",
                "params": "نمرر المصفوفة التي نريد الحصول على أكبر قيمة فيها . set مكان الباراميتر ",
                "return": "ترجع أكبر قيمة موجودة في الكلاس الذي نمرره لها عند استدعائها .",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["set"],
                        "logic": lambda vals: max(strict_type("set", vals[0])) 
                            if isinstance(strict_type("set", vals[0]), set) 
                            else strict_type("set", vals[0])
                    }
                ]    
            },
            "set(sequence)":{
                "definition": "مثل السلاسل النصية، المجموعات، القواميس، أو حتى الكائنات المخصصة (iterable) تُستخدم لتحويل أي كائن قابل للتكرار \n (set) إلى كائن من نوع قائمة",
                "syntax": "set(sequence)",
                "params": "نمرر كائن يحتوي مجموعة عناصر  . sequence مكان الباراميتر ",
                "return": "set ترجع نسخة من أي كائن يحتوي مجموعة عناصر نمرره لها عند إستدعائها ككائن من الكلاس",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["sequence"],
                        "logic": lambda vals: set(eval(vals[0]))
                    }
                ]    
            }
        }    
    },
    "Dict دوال الكلاس ":{
        "دوال الوصول والفحص":{
            "get(key,default)":{
                "definition": "وترجعها key الذي قام باستدعائها عن قيمة المفتاح الذي نمرره لها مكان الباراميتر  dict تبحث في كائن الـ",
                "syntax": "dict.get(key, default)",
                "params": "default : هو باراميتر إختياري، مكانه يمكن تمرير قيمة إفتراضية ليتم إرجاعها في حال لم يتم العثور على عنصر يملك \n المفتاح الذي مررناه لها. \n key : باراميتر نمرر مكانه مفتاح العنصر الذي نريد الحصول على قيمته",
                "return": "في حال تم إيجاد عنصر يملك المفتاح dict ترجع قيمة المفتاح المراد البحث عنها في الـ \n في حال لم يتم إيجاد عنصر يملك المفتاح و لم نمرر لها قيمة إفتراضية None ترجع \n في حال تم تمرير قيمة إفتراضية لها و لم يتم إيجاد عنصر يملك المفتاح المراد الحصول على قيمته، فإنها ترجع القيمة الإفتراضية",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict", "key", "default"],
                        "logic": lambda vals: eval(vals[0]).get(eval(vals[1]), eval(vals[2]) if vals[2].strip() else None)

                    }
                ]
            },
            "keys()":{
                "definition": "الذي قام باستدعائها dict فيها جميع المفاتيح الموجودة في كائن الـ dict_keys ترجع مصفوفة نوعها \n بل هي نفسها dict ملاحظة: مصفوفة المفاتيح التي ترجعها ليست نسخة عن المفاتيح الموجودة في كائن الـ \n نفسه و العكس كذلك. dict و بالتالي أي تعديل يتم إجراؤه عليها ينعكس على المفاتيح الموجودة في كائن الـ",
                "syntax": "dict.keys()",
                "params": "لا تقبل اي باراميتر",
                "return": "ترجع ما ذكرناه في تعريفها",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: f"dict_keys({list(eval(vals[0]).keys())})"
                    }
                ]
            },
            "values()":{
                "definition": "الذي قام باستدعائها dict فيها جميع القيم الموجودة في كائن الـ dict_keys ترجع مصفوفة نوعها \n بل هي نفسها dict ملاحظة: مصفوفة القيم التي ترجعها ليست نسخة عن القيم الموجودة في كائن الـ \n نفسه و العكس كذلك. dict و بالتالي أي تعديل يتم إجراؤه عليها ينعكس على القيم الموجودة في كائن الـ",
                "syntax": "dict.values()",
                "params": "لا تقبل اي باراميتر",
                "return": "ترجع ما ذكرناه في تعريفها",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: f"dict_values({list(eval(vals[0]).values())})"
                    }
                ]
            },
            "items()":{
                "definition": "الذي قام باستدعائها dict فيها جميع العناصر الموجودة في كائن الـ dict_keys ترجع مصفوفة نوعها \n بل هي نفسها dict ملاحظة: مصفوفة العناصر التي ترجعها ليست نسخة عن العناصر الموجودة في كائن الـ \n نفسه و العكس كذلك. dict و بالتالي أي تعديل يتم إجراؤه عليها ينعكس على العناصر الموجودة في كائن الـ",
                "syntax": "dict.items()",
                "params": "لا تقبل اي باراميتر",
                "return": "ترجع ما ذكرناه في تعريفها",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: f"dict_items({list(eval(vals[0]).items())})"
                    }
                ]
            }
        },
        "دوال التعديل":{
            "update(other_dict)":{
                "definition": "الذي قام باستدعائها على أساس المفاتيح الموجودة فيه. dict تستخدم لتحديث قيم عناصر الـ ",
                "syntax": "dict.update(other_dict)",
                "params": " الذي قام باستدعائها dict فيه عنصر واحد أو مجموعة العناصر التي نريد تحديث قيمها في كائن الـ dict هو باراميتر  نمرر مكانه كائن  : other_dict\n الذي قام باستدعائها سيتم إضافته فيه dictيملك مفتاح غير موجود في كائن الـ other_dict أي عنصر نمرره مكان الباراميتر ",
                "return": "None ترجع القاموس بعد التحديث،وليس",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict", "other_dict"],
                        "logic": lambda vals: (
                            (lambda d, other: (d.update(other) or d))(
                            ast.literal_eval(vals[0]),
                            ast.literal_eval(vals[1])
                        )
                        )
                    }
                ]
            },
            "pop(key,default)":{
                "definition": "  الذي قام باستدعائها عن عنصر يملك نفس المفتاح   dict تبحث في كائن الـ \n وفي حال وجدته ترجعه ومن ثم تحذفه key  الذي نمرره لها مكان الباراميتر",
                "syntax": "dict.pop(key,default)",
                "params": "نمرر مفتاح العنصر الذي نريد الحصول عليه key مكان الباراميتر \n هو باراميتر إختياري، مكانه يمكن تمرير قيمة إفتراضية ليتم إرجاعها في حال لم يتم العثور . : default \n على عنصر يملك المفتاح الذي مررناه لها",
                "return": "default أو ترجع القيمة الإفتراضية التي تم تمريرها مكان الباراميتر  dictترجع العنصر الذي تم حذفه من الـ \n  key  أخطاء محتملة:في حال لم يتم العثور على عنصر يملك المفتاح الذي تم وضعه مكان الباراميتر \n KeyError فإنها ترمي الإستثناء  default و لم يتم وضع قيمة إفتراضية مكان الباراميتر ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict", "key","default"],
                        "logic": lambda vals: (
                            (lambda d, k, default: (
                                d.pop(k) if default == "" else d.pop(k, default)
                            ))(
                                ast.literal_eval(vals[0]),   # تحويل النص إلى قاموس
                                ast.literal_eval(vals[1]),   # المفتاح
                                ast.literal_eval(vals[2]) if vals[2] != "" else ""  # القيمة الافتراضية إذا موجودة
                            )
                        )

                    }
                ]
            },
            "popitem()":{
                "definition": "الذي قام باستدعائها و من ثم تحذفه منه. dictترجع آخر عنصر تم إضافته في كائن الـ \n KeyError في حال لم يتم العثور على القيمة المراد حذفها ترمي الإستثناء ",
                "syntax": "dict.popitem()",
                "params": "لا تقبل أي باراميتر",
                "return": "dict ترجع العنصر الذي تم حذفه من ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: ((lambda d: f"المحذوف: {d.popitem()}\nالقاموس بعد الحذف: {d}")(ast.literal_eval(vals[0])))
                    }
                ]
            },
            "setdefault(key,default)":{
                "definition": "الذي قام باستدعائها . dict تستخدم للحصول على قيمة مفتاح موجود في كائن الـ \n أو لإضافة عنصر جديد فيه مع إرجاع قيمته أيضاً",
                "syntax": "dict.setdefault(key,default)",
                "params": ". dict نمرر مفتاح العنصر الذي إن كان موجوداً في كائن الـ key	مكان الباراميتر \n سيتم إرجاع قيمته فقط و إن لم يكن موجوداً فسيتم إضافته و إرجاع قيمته\n  هو باراميتر إختياري، مكانه يمكن تمرير قيمة أولية ليتم وضعها في العنصر في حال تم إضافته 	default \n None لأنه إفتراضياً إن تم إضافة عنصر جديد فإنه قيمته تكون",
                "return": "key ترجع قيمة المفتاح الذي تم تمريره لها مكان الباراميتر ",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict", "key", "default "],
                        "logic": lambda vals: (
                            (lambda d, k, default: (
                            f"القيمة المرجعة: {d.setdefault(k) if default == '' else d.setdefault(k, default)}\nالقاموس بعد التنفيذ: {d}"
                            ))(
                                ast.literal_eval(vals[0]),
                                ast.literal_eval(vals[1]),
                                ast.literal_eval(vals[2]) if vals[2] != "" else ""
                            )
                        )

                    }
                ]
            }
        },
        "دوال الفحص والتنظيف":{
            "clear()":{
                "definition": "تستخدم لحذف جميع عناصر القاموس الذي قام باستدعائها",
                "syntax": "dict.clear()",
                "params": "لا تقبل أي باراميتر",
                "return": "لا ترجع قيمة",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: (
                            (lambda d: f"تم حذف جميع العناصر\nالقاموس الآن: {d}")(
                                (lambda d: (d.clear() or d))(ast.literal_eval(vals[0]))
                            )
                        )
                    }
                ]
            },
            "copy()":{
                "definition": "ترجع نسخة من القاموس الذي قام باستدعائها",
                "syntax": "dict.copy()",
                "params": "لا تقبل أي باراميتر",
                "return": "ترجع نسخة من القاموس الذي قام باستدعائها",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict"],
                        "logic": lambda vals: (
                            (lambda d_original: (
                                (lambda d_copy: f"القاموس الأصلي : {d_original}\nنسخة عن القاموس : {d_copy}")
                                (d_original.copy())
                            ))(ast.literal_eval(vals[0]))
                        )
                    }
                ]
            },
            "fromkeys(seq,value)":{
                "definition": "تستخدم لإنشاء قاموس جديد مبني على قيم مصفوفة نمررها له",
                "syntax": "dict.fromkeys(seq,value)",
                "params": "عناصر هذا الكائن tuple أو setأو list باراميتر نمرر مكانه كائن من اي نوع كان سواء :seq=sequence \n يتم وضعها كمفاتيح في القاموس الذي سيتم إنشاءه \n هو باراميتر اختياري مكانه يمكن تمرير قيمة واحده ليتم وضعها كقيمة أولية لجميع عناصر القاموس:value\n None فستكون جميع قيم عناصره تساوي  value في حال لم يتم تمرير قيمة مكان الباراميتر",
                "return": "ترجع قاموس جديد",
                "examples": [
                    {  
                        "title": "مثال",
                        "inputs": ["dict","seq","value"],
                        "logic": lambda vals: (
                            (lambda d, k, value: (
                                f"تم إنشاء قاموس جديد باستخدام fromkeys\n"
                                f"القيمة المرجعة: {d.fromkeys(k) if value == '' else d.fromkeys(k, value)}\n"
                                f"القاموس الأصلي لم يتغير: {d}"
                            ))(
                                ast.literal_eval(vals[0]),
                                ast.literal_eval(vals[1]),
                                ast.literal_eval(vals[2]) if vals[2] != "" else ""
                            )
                        )
                    }
                ]
            }
        }
    },
    "دوال التاريخ والوقت":{
        "datetime.datetime الموديل.الكلاس":{
            "now()":{
                    "definition": "datetime تُستخدم للحصول على الوقت والتاريخ الحالي حسب توقيت النظام، وترجع كائن من نوع \n قد تختلف النتيجة حسب إعدادات التوقيت المحلي للنظام.\n يتيح لنا الحصول على التاريخ والوقت بدقة عالية لأنه أعطانا المعلومات التالية بالترتيب: السنة، الشهر، اليوم\n الساعة، الدقيقة، الثانية، أجزاء الثانية القادمة",
                    "syntax": "datetime.datetime.now()",
                    "params": "لا تأخذ أي باراميتر.",
                    "return": " datetime  ترجع كائن يحتوي على التاريخ والوقت الحالي.\n أولًا datetime يجب استيراد الموديول\n تضيفه للناتج timezone إذا مررنا لها ",
                    "examples": [
                        {
                            "title": "عرض التاريخ و الوقت الحالي",
                            "inputs": [],
                            "logic": lambda vals: show_datetime_now()
                    }
                ]
            },
            "today()":{
                "definition": "(timezone) ترجع التاريخ والوقت الحالي حسب توقيت النظام، بدون معلومات المنطقة الزمنية.\n لا تضيفه للناتج  timezoneإذا مررنا لها",
                "syntax": "datetime.datetime.today()",
                "params": "لا تأخذ أي باراميتر.",
                "return": " datetime كائن يحتوي على التاريخ والوقت الحالي.",
                "examples": [
                    {
                        "title": "today() عرض التاريخ والوقت باستخدام ",
                        "inputs": [],
                        "logic": lambda vals: show_datetime_today()
                    }
                ]   
            },
            "utcnow()": {
                "definition": "(التوقيت العالمي المنسّق) UTCترجع التاريخ والوقت الحالي حسب توقيت \n timezone بدون معلومات",
                "syntax": "datetime.datetime.utcnow()",
                "params": "لا تأخذ أي باراميتر.",
                "return": "UTC يحتوي على التاريخ والوقت بتوقيت datetimeكائن .",
                "examples": [
                    {
                        "title": "UTC عرض التاريخ والوقت بتوقيت",
                        "inputs": [],
                        "logic": lambda vals: show_datetime_utcnow()
                    }
                ]
            },
            "fromtimestamp(timestamp)": {
                "definition": "datetime إلى كائن timestampتحوّل رقم \n OverflowError إذا كان الرقم غير صالح أو كبير جدًا، يعطي خطأ",
                "syntax": "datetime.datetime.fromtimestamp(timestamp)",
                "params": "1970-01-01 رقم عشري يمثل عدد الثواني منذ :timestamp",
                "return": "يمثل التاريخ والوقت الموافق لهذا الرقم datetimeكائن ",
                "examples": [
                    {
                            "title": "datetime إلى timestampتحويل رقم ",
                            "inputs": [""],  # مستطيل إدخال واحد
                            "logic": lambda vals: show_datetime_fromtimestamp(vals[0]),
                            "sidebar": (
                                "🧮 أمثلة على أرقام timestamp:\n\n"
                                "0           31536000     63072000     94694400\n"
                                "126230400   157766400    189302400    220924800\n"
                                "252460800   283996800    315532800    347155200\n"
                                "378691200   410227200    441763200    473385600\n"
                                "504921600   536457600    567993600    599616000\n"
                                "631152000   662688000    694224000    725846400\n"
                                "757382400   788918400    820454400    852076800\n"
                                "883612800   915148800    946684800    1609459200"
                            )
                    }
                ]
            },
            "strftime(format)": {
                "definition": "%Y و %m و %d إلى سلسلة نصية بصيغة تحددها باستخدام رموز مثل  datetimeتحوّل كائن \n TypeError تعطي الخطأ datetime إذا لم يكن التنسيق سلسلة نصية، أو إذا كان الكائن ليس .",
                "syntax": "datetime.datetime.strftime(format)",
                "params": " لليوم، إلخ %d ،للشهر %m ,للسنة %Y  سلسلة تحتوي رموز تنسيق مثل: format",
                "return": "سلسلة نصية تمثل التاريخ/الوقت حسب التنسيق المطلوب.",
                "examples": [
                    {
                        "title": "تنسيقات متعددة لعرض التاريخ والوقت",
                        "inputs": [
                            "%d/%m/%Y",     # مثال: 11/11/2025
                            "%H:%M:%S",     # مثال: 22:55:00
                            "%A, %B"        # مثال: Tuesday, November
                        ],
                        "logic": lambda vals: [
                                       datetime.datetime.now().strftime(v) for v in vals if v.strip()
                        ],
                        "sidebar": (
                            "🧭 أمثلة على تنسيقات التاريخ والوقت:\n\n"
                            "%d/%m/%Y   |  11/11/2025   ← يوم/شهر/سنة\n"
                            "%Y-%m-%d   |  2025-11-11   ← سنة-شهر-يوم\n"
                            "%A, %B     |  Tuesday, November ← اسم اليوم والشهر\n"
                            "%H:%M:%S   |  22:55:00     ← الوقت بصيغة 24 ساعة\n"
                            "%I:%M %p   |  10:55 PM     ← الوقت بصيغة 12 ساعة\n"
                            "%Y         |  2025         ← السنة فقط\n"
                            "%B         |  November     ← اسم الشهر\n"
                            "%A         |  Tuesday      ← اسم اليوم\n"
                            "%d         |  11           ← رقم اليوم\n"
                            "%m         |  11           ← رقم الشهر\n"
                            "%S         |  00           ← الثواني\n"
                        )
                    }
                ]
            },
            "strptime(date_string, format)": {
                "definition": "باستخدام تنسيق محدد datetimeتحوّل سلسلة نصية تمثل تاريخًا أو وقتًا إلى كائن  .\n ValueErrorأو إذا لم تتطابق السلسلة مع التنسيق تعطي الخطأ،  TypeError إذا كانت المدخلات غير نصية.",
                "syntax": "datetime.datetime.strptime(date_string, format)",
                "params": " سلسلة نصية تحتوي على التاريخ أو الوقت :date_string\nلليوم إلخ %d , للشهر %m , للسنة %Yسلسلة تحتوي رموز تنسيق مثل :format.",
                "return": "كائن  يمثل التاريخ/الوقت المستخرج من السلسلة النصية datetime",
                "examples": [
                    {
                        "title": "باستخدام تنسيقات متعددة datetimeتحويل نص إلى كائن  ",
                        "inputs": [
                            "%a", "%A", "%w", "%d","%b", "%B", "%m", "%M", "%y", "%Y",
                            "%H", "%I", "%p", "%S", "%f", "%j", "%U", "%c", "%x", "%X"
                        ],
                        "logic": lambda vals: [
                            f"إذا استخدمنا {v} → الناتج: {datetime.datetime.now().strftime(v)}"
                            for v in vals if v.strip()
                        ],
                        "sidebar": (
                                "🧭 رموز تنسيق التاريخ والوقت:\n\n"
                                "%a | Mon       ← اسم اليوم المختصر\n"
                                "%A | Monday    ← اسم اليوم الكامل\n"
                                "%w | 1         ← رقم اليوم في الأسبوع\n"
                                "%d | 10        ← رقم اليوم في الشهر\n"
                                "%b | Nov       ← اسم الشهر المختصر\n"
                                "%B | November  ← اسم الشهر الكامل\n"
                                "%m | 11        ← رقم الشهر\n"
                                "%M | 02        ← الدقائق\n"
                                "%y | 25        ← آخر رقمين من السنة\n"
                                "%Y | 2025      ← السنة كاملة\n"
                                "%H | 17        ← الساعة (24)\n"
                                "%I | 05        ← الساعة (12)\n"
                                "%p | PM        ← AM أو PM\n"
                                "%S | 26        ← الثواني\n"
                                "%f | 003893    ← الميكروثواني\n"
                                "%j | 314       ← رقم اليوم في السنة\n"
                                "%U | 45        ← رقم الأسبوع في السنة\n"
                                "%c | Mon Nov 10 17:02:26 2025 ← التمثيل الكامل\n"
                                "%x | 11/10/25  ← التاريخ المحلي\n"
                                "%X | 17:02:26  ← الوقت المحلي\n\n"
                                "💡 ملاحظة: يمكن دمج أكثر من رمز في أمر واحد مثل \"%Y-%m-%d %H:%M:%S\""
                        )

                    }
                ]
            },
            "combine(date, time)": {
                "definition": " يحتوي على التاريخ والوقت معًا datetime لإنشاء كائن time مع كائن من النوع dateتدمج كائن من النوع .\nTypeError  إذا لم تكن المدخلات من النوعين الصحيحين تعطي الخطأ",
                "syntax": "datetime.datetime.combine(date, time)",
                "params": " datetime.date كائن من النوع :date\n\n datetime.time كائن من النوع :time",
                "return": "يحتوي على التاريخ والوقت المدمجين datetime كائن ",
                "examples": [
                    {
                        "title": "واحد datetimeدمج تاريخ ووقت في كائن  ",
                        "inputs": [
                            "date(2025, 11, 12)",   # مثال: تاريخ
                            "time(14, 30)"          # مثال: وقت
                        ],
                        "logic": lambda vals: [
                            f"إذا دمجنا {vals[0]} و {vals[1]} → الناتج:\n {datetime.datetime.combine(eval(vals[0], {'date': datetime.date}), eval(vals[1], {'time': datetime.time}))}"
                            if len(vals) >= 2 and vals[0].strip() and vals[1].strip()
                            else "يرجى إدخال تاريخ ووقت بصيغة صحيحة مثل: date(2025, 11, 12) و time(14, 30)"
                        ],
                        "sidebar": (
                            "🧭 دمج التاريخ والوقت:\n\n"
                            "date(2025, 11, 12) + time(14, 30) → datetime(2025, 11, 12, 14, 30)\n"
                            "date.today() + time(9, 0)         → datetime(اليوم, 9:00 صباحًا)\n"
                            "date(2023, 1, 1) + time(0, 0)     → منتصف الليل في أول يوم من السنة\n\n"
                            "💡 ملاحظة: يمكن استخدام eval() لتحويل النص إلى كائنات فعلية من النوع date و time"
                        )
                    }
                ]
            },
            "replace": {
                "definition": "مع تعديل جزء منه مثل السنة أو الساعة datetimeتُعيد نسخة جديدة من كائن  .\n ValueError إذا كانت القيم غير منطقية (مثل شهر = 13) تعطي الخطأ.",
                "syntax": "datetime.datetime.replace(year=..., month=..., day=..., hour=..., ...)",
                "params": "year, month, day, hour, minute, second, microsecond: كلها اختيارية ويمكن تعديل أي منها.",
                "return": "جديد يحتوي على التعديلات المطلوبة datetimeكائن  .",
                "examples": [
                    {
                        "title": "datetime تعديل ساعة وتاريخ في كائن ",
                        "inputs": [
                            "datetime(2025, 11, 12, 14, 30)",  # الكائن الأصلي
                            "year=2026, hour=9, minute=0"      # التعديلات
                        ],
                        "logic": lambda vals: [
                            f"إذا عدّلنا {vals[0]} باستخدام {vals[1]} → الناتج: {eval(vals[0], {'datetime': datetime.datetime}).replace(**{k.strip().split('=')[0]: int(k.strip().split('=')[1]) for k in vals[1].split(',')})}"
                            if len(vals) >= 2 and vals[0].strip() and vals[1].strip()
                            else "يرجى إدخال كائن datetime وتعديلات بصيغة year=..., hour=..., إلخ"
                        ],
                        "sidebar": (
                            "🧭 تعديل أجزاء من datetime:\n\n"
                            "datetime(2025, 11, 12, 14, 30).replace(hour=9) → 2025-11-12 09:30:00\n"
                            "datetime.now().replace(minute=0, second=0)    → بداية الساعة الحالية\n"
                            "datetime(2023, 1, 1).replace(year=2025)        → 2025-01-01\n\n"
                            "💡 ملاحظة: replace() لا يغيّر الكائن الأصلي، بل يُعيد نسخة جديدة معدّلة"
                        )
                    }
                ]
            },
            "astimezone(tz)": {
                "definition": "tzinfo إلى منطقة زمنية جديدة باستخدام كائن datetimeتحوّل كائن \n ValueErrorتعطي الخطأ tzinfo إذا لم يكن الكائن يحتوي على",
                "syntax": "datetime.datetime.astimezone(tz)",
                "params": " timezone(timedelta(hours=3)) أو timezone.utc : مثل tzinfo كائن من النوع :tz ",
                "return": "جديد يمثل نفس اللحظة الزمنية لكن في المنطقة الزمنية الجديدة datetimeكائن ",
                "examples": [
                    {
                        "title": "إلى توقيت محلي +3 UTC تحويل توقيت  ",
                        "inputs": [
                            "datetime(2025, 11, 12, 14, 30, tzinfo=timezone.utc)",
                            "timezone(timedelta(hours=3))"
                        ],
                        "logic": lambda vals: [
                            f"إذا حوّلنا {vals[0]} إلى {vals[1]} → الناتج: {eval(vals[0], {'datetime': datetime.datetime, 'timezone': datetime.timezone, 'timedelta': datetime.timedelta}).astimezone(eval(vals[1], {'timezone': datetime.timezone, 'timedelta': datetime.timedelta}))}"
                            if len(vals) >= 2 and vals[0].strip() and vals[1].strip()
                            else "يرجى إدخال كائن datetime يحتوي على tzinfo، وكائن timezone مثل timezone(timedelta(hours=3))"
                        ],
                        "sidebar": (
                            "🧭 تحويل المناطق الزمنية:\n\n"
                            "datetime(..., tzinfo=timezone.utc).astimezone(timezone(timedelta(hours=3))) → توقيت محلي +3\n"
                            "datetime.now(timezone.utc).astimezone(timezone(timedelta(hours=1))) → توقيت أوروبا الوسطى\n\n"
                            "💡 ملاحظة: astimezone() لا يغيّر اللحظة الزمنية، بل طريقة عرضها حسب المنطقة الزمنية الجديدة"
                        )
                    }
                ]
            },
            "astimezone": {
                "definition": "إلى منطقة زمنية جديدة باستخدام فرق التوقيت أو اسم مدينة datetimeتحوّل كائن .\n ValueErrorيتم رفع  tzinfoإذا لم يكن الكائن يحتوي على",
                "syntax": "datetime.datetime.astimezone(tz)",
                "params": " ZoneInfo(city) أو timezone(timedelta(hours=n))   tz يمكن أن يكون ",
                "return": "جديد يمثل نفس اللحظة الزمنية لكن في المنطقة الزمنية الجديدة، مع مراعاة التوقيت الصيفي إن وجد datetimeكائن ",
                "examples": [
                    {
                        "title": " أو اسم مدينة hour إلى توقيت محلي باستخدام UTCتحويل توقيت    ",
                        "inputs": ["2025-11-12 14:30 | utc", "damascus"],
                        "logic": lambda vals: [
                (
                    lambda dt, tz: f"إذا حوّلنا {vals[0]} إلى {vals[1]} → الناتج: {dt.astimezone(tz).strftime('%H:%M:%S %d-%m-%Y')} | المنطقة: {tz.tzname(dt)} | فرق التوقيت: {dt.astimezone(tz).utcoffset()}"
                )(
                    datetime.datetime.strptime(vals[0].split('|')[0].strip(), '%Y-%m-%d %H:%M')
                    .replace(tzinfo=datetime.timezone.utc if vals[0].split('|')[1].strip().lower() == 'utc' else None),
                    datetime.timezone(datetime.timedelta(hours=int(vals[1].split('=')[1])))
                    if vals[1].strip().lower().startswith("hour=")
                    else ZoneInfo({
                        "damascus": "Asia/Damascus",
                        "newyork": "America/New_York",
                        "london": "Europe/London",
                        "tokyo": "Asia/Tokyo",
                        "paris": "Europe/Paris",
                        "cairo": "Africa/Cairo",
                        "utc": "UTC"
                    }.get(vals[1].strip().lower(), "UTC"))
                )
                if len(vals) >= 2 and all(v.strip() for v in vals)
                else "يرجى إدخال التاريخ والوقت بصيغة YYYY-MM-DD HH:MM | utc أو local، ثم hour=رقم أو اسم مدينة\n"
            ],
                        "sidebar": "🧭 تحويل المناطق الزمنية:\n\n"
                                   "datetime(..., tzinfo=timezone.utc).astimezone(timezone(timedelta(hours=3))) → توقيت محلي +3\n"
                                   "datetime.now(timezone.utc).astimezone(ZoneInfo('America/New_York')) → توقيت نيويورك\n\n"
                                   "📥 الإدخال:\n"
                                   "المستطيل الأول: YYYY-MM-DD HH:MM | utc أو local\n"
                                   "المستطيل الثاني: hour=رقم أو اسم مدينة (مثال: hour=3 أو damascus)\n\n"
                                   "🌍 أمثلة على المناطق الزمنية:\n"
                                   "hour=3       | توقيت دمشق\n"
                                   "newyork      | توقيت نيويورك (مع دعم التوقيت الصيفي)\n"
                                   "tokyo        | توقيت طوكيو\n"
                                   "london       | توقيت لندن\n"
                                   "paris        | توقيت باريس\n"
                                   "cairo        | توقيت القاهرة\n\n"
                                   "💡 ملاحظة: astimezone() لا يغيّر اللحظة الزمنية، بل طريقة عرضها حسب المنطقة الزمنية الجديدة"
                    }
                ]
            },
            "timestamp()": {
                "definition": "UTC إلى عدد عشري يمثل عدد الثواني منذ 1970-01-01 datetimeتحوّل كائن   .\n OSError إذا كان التاريخ قبل 1970 أو غير صالح تعطي الخطأ.",
                "syntax": "datetime.datetime.timestamp()",
                "params": "datetime لا تأخذ معاملات، تُستخدم مباشرة على كائن",
                "return": "يمثل عدد الثواني منذ بداية العصر الزمني (float)عدد عشري ",
                "examples": [
                    {
                        "title": "إلى طابع زمني رقمي datetimeتحويل ",
                        "inputs": [
                            "datetime(2025, 11, 12, 14, 30)"
                        ],
                        "logic": lambda vals: [
                            f"الطابع الزمني لـ {vals[0]} هو: {eval(vals[0], {'datetime': datetime.datetime}).timestamp()}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال كائن datetime مثل: datetime(2025, 11, 12, 14, 30)"
                        ],
                        "sidebar": (
                            "🧭 تحويل datetime إلى رقم:\n\n"
                            "datetime(2025, 11, 12, 14, 30).timestamp() → 1762948200.0\n"
                            "datetime.now().timestamp() → عدد الثواني منذ 1970 حتى الآن\n\n"
                            "💡 ملاحظة: الطابع الزمني مفيد للتخزين والمقارنة بدقة عالية"
                        )
                    }
                ]
            }
        },
        "datetime.date الموديل_الكلاس":{
            "date.today": {
                "definition": "ترجع تاريخ اليوم حسب توقيت النظام المحلي، بدون وقت أو ساعة.",
                "syntax": "datetime.date.today()",
                "params": "لا تأخذ أي معاملات",
                "return": "يمثل تاريخ اليوم date كائن",
                "examples": [
                    {
                        "title": "الحصول على تاريخ اليوم",
                        "inputs": [],
                        "logic": lambda vals: f"تاريخ اليوم هو: {datetime.date.today()}",
                    }
                ]
            },
            "fromtimestamp(timestamp)": {
                "definition": "   يمثل التاريخ فقط date إلى كائن  timestampتحوّل رقم \n (عدد الثواني منذ 1970-01-01) timestamp",
                "syntax": "datetime.date.fromtimestamp(timestamp)",
                "params": "timestamp: رقم عشري أو صحيح يمثل عدد الثواني منذ 1970-01-01 00:00:00 UTC",
                "return": "يمثل التاريخ الموافق للرقم الزمني dateكائن  ",
                "examples": [
                    {
                        "title": "إلى تاريخ timestampتحويل رقم  ",
                        "inputs": ["1294140780.0"],
                        "logic": lambda vals: (
                            f"الرقم {vals[0]} يمثل التاريخ: {datetime.date.fromtimestamp(float(vals[0]))}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال رقم timestamp مثل: 1294140780.0"
                        ),
                        "sidebar": "🕓 تحويل رقم timestamp إلى تاريخ:\n\n"
                                "استخدم date.fromtimestamp(timestamp) لتحويل رقم إلى كائن تاريخ.\n\n"
                                "📥 الإدخال:\n"
                                "المستطيل الأول: رقم timestamp (مثال: 1294140780.0)\n\n"
                                "🌟 أمثلة جاهزة:\n"
                                "1294140780.0 → 2011-01-04\n"
                                "946684800.0  → 2000-01-01\n"
                                "1609459200.0 → 2021-01-01\n"
                                "1700000000.0 → 2023-11-14\n\n"
                                "💡 ملاحظة: الناتج هو التاريخ فقط بدون وقت."
                                "💡 ملاحظة:\n"
                                "للحصول على رقم timestamp الصحيح، استخدم:\n"
                                "datetime.datetime(السنة, الشهر, اليوم, الساعة, الدقيقة).timestamp()"
                    }
                ]
            },
            "isoformat": {
                "definition": "(YYYY-MM-DD) القياسية ISO 8601 ترجع تمثيل التاريخ بصيغة ",
                "syntax": "date_object.isoformat()",
                "params": "date لا تأخذ معاملات. تُستخدم على كائن من النوع",
                "return": "YYYY-MM-DD سلسلة نصية تمثل التاريخ بصيغة ",
                "examples": [
                    {
                        "title": "ISO تحويل كائن تاريخ إلى سلسلة ",
                        "inputs": ["2025-11-12"],
                        "logic": lambda vals: (
                            f"التاريخ {vals[0]} بصيغة ISO هو: {datetime.date.fromisoformat(vals[0].strip().replace('\n', '').replace('\r', '')).isoformat()}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD"
                        ),
                        "sidebar": "📆 تحويل التاريخ إلى صيغة ISO:\n\n"
                                "استخدم date.isoformat() للحصول على تمثيل قياسي للتاريخ.\n\n"
                                "📥 الإدخال:\n"
                                "المستطيل الأول: تاريخ بصيغة YYYY-MM-DD\n\n"
                                "📤 الناتج:\n"
                                "سلسلة نصية مثل: '2025-11-12'\n\n"
                                "🌟 مثال:\n"
                                "datetime.date(2025, 11, 12).isoformat() → '2025-11-12'\n\n"
                                "💡 مفيد للتخزين، التصدير، أو المقارنة بين التواريخ."
                                "💡 ملاحظة:\n"
                                "الدالة لا تصلّح أو تعدّل التاريخ. فائدتها الأساسية هي الحصول على تمثيل قياسي للتاريخ عند الحاجة للتخزين أو التصدير."
                    }
                ]
            },
            "strftime(format)": {
                "definition": " %Y و %d ترجع التاريخ كنص منسّق حسب القالب الذي تحدده باستخدام رموز تنسيق مثل",
                "syntax": "date_object.strftime(format)",
                "params": " '%d/%m/%Y' سلسلة تحتوي رموز تنسيق مثل :format",
                "return": "سلسلة نصية تمثل التاريخ حسب التنسيق المطلوب",
                "examples": [
                    {
                        "title": "تنسيق التاريخ حسب قالب مخصص",
                        "inputs": ["2025-11-12", "%A, %d %B %Y"],
                        "logic": lambda vals: (
                            f"التاريخ {vals[0]} بالتنسيق '{vals[1]}' هو: {datetime.date.fromisoformat(vals[0].strip()).strftime(vals[1])}"
                            if vals and len(vals) == 2 and vals[0].strip() and vals[1].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD والقالب المطلوب مثل '%d/%m/%Y'"
                        ),
                        "sidebar": "🧾 تنسيق التاريخ حسب قالب مخصص:\n\n"
                                "استخدم date.strftime(format) لتحويل التاريخ إلى نص منسّق.\n\n"
                                "📥 الإدخال:\n"
                                "المستطيل الأول: تاريخ بصيغة YYYY-MM-DD\n"
                                "المستطيل الثاني: قالب التنسيق مثل '%d/%m/%Y'\n\n"
                                "📤 الناتج:\n"
                                "سلسلة نصية تمثل التاريخ حسب القالب\n\n"
                                "🌟 أمثلة:\n"
                                "'%d/%m/%Y' → '12/11/2025'\n"
                                "'%A, %d %B %Y' → 'Wednesday, 12 November 2025'\n\n"
                                "📌 جدول الرموز:\n"
                                "%Y: السنة | %m: الشهر | %d: اليوم | %A: اسم اليوم | %B: اسم الشهر"
                    }
                ]
            },
            "weekday": {
                "definition": "ترجع رقم اليوم في الأسبوع (0 = الإثنين، 6 = الأحد).",
                "syntax": "date_object.weekday()",
                "params": "date لا تأخذ معاملات. تُستخدم على كائن من النوع .",
                "return": "عدد صحيح من 0 إلى 6 يمثل ترتيب اليوم في الأسبوع.",
                "examples": [
                    {
                        "title": "تحديد رقم اليوم في الأسبوع",
                        "inputs": ["2025-11-12"],
                        "logic": lambda vals: (
                            f"📅 التاريخ {vals[0]} هو يوم رقم: {datetime.date.fromisoformat(vals[0].strip()).weekday()} (حيث 0 = الإثنين)"
                            if vals and vals[0].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD"
                        ),
                        "sidebar": "📆 تحديد رقم اليوم في الأسبوع:\n\n"
                                "استخدم date.weekday() للحصول على رقم اليوم في الأسبوع.\n\n"
                                "📥 الإدخال:\n"
                                "المستطيل الأول: تاريخ بصيغة YYYY-MM-DD\n\n"
                                "📤 الناتج:\n"
                                "عدد صحيح من 0 إلى 6\n\n"
                                "🌟 مثال:\n"
                                "2025-11-12 → 2 (أي الأربعاء)\n\n"
                                "📌 الترتيب:\n"
                                "0 = الإثنين | 1 = الثلاثاء | 2 = الأربعاء | 3 = الخميس | 4 = الجمعة | 5 = السبت | 6 = الأحد"
                    }
                ]
            },
            "year": {
                "definition": "ترجع السنة من كائن التاريخ.",
                "syntax": "date_object.year",
                "params": "date لا تأخذ معاملات. تُستخدم على كائن من النوع",
                "return": "عدد صحيح يمثل السنة.",
                "examples": [
                    {
                        "title": "استخراج السنة من التاريخ",
                        "inputs": ["2025-11-12"],
                        "logic": lambda vals: (
                            f"السنة هي: {datetime.date.fromisoformat(vals[0].strip()).year}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD"
                        ),
                        "sidebar": "📅 استخراج السنة من التاريخ:\n\n"
                                "استخدم date.year للحصول على السنة من كائن التاريخ.\n\n"
                                "📥 الإدخال: تاريخ بصيغة YYYY-MM-DD\n"
                                "📤 الناتج: عدد صحيح يمثل السنة\n\n"
                                "🌟 مثال:\n"
                                "2025-11-12 → 2025"
                    }
                ]
            },
            "month": {
                "definition": "ترجع رقم الشهر من كائن التاريخ.",
                "syntax": "date_object.month",
                "params": "date لا تأخذ معاملات. تُستخدم على كائن من النوع",
                "return": "عدد صحيح من 1 إلى 12 يمثل رقم الشهر.",
                "examples": [
                    {
                        "title": "استخراج رقم الشهر",
                        "inputs": ["2025-11-12"],
                        "logic": lambda vals: (
                            f"رقم الشهر هو: {datetime.date.fromisoformat(vals[0].strip()).month}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD"
                        ),
                        "sidebar": "📆 استخراج رقم الشهر:\n\n"
                                "استخدم date.month للحصول على رقم الشهر من كائن التاريخ.\n\n"
                                "📥 الإدخال: تاريخ بصيغة YYYY-MM-DD\n"
                                "📤 الناتج: عدد صحيح من 1 إلى 12\n\n"
                                "🌟 مثال:\n"
                                "2025-11-12 → 11"
                    }
                ]
            },
            "day": {
                "definition": "ترجع رقم اليوم من كائن التاريخ.",
                "syntax": "date_object.day",
                "params": "date لا تأخذ معاملات. تُستخدم على كائن من النوع",
                "return": "عدد صحيح من 1 إلى 31 يمثل رقم اليوم.",
                "examples": [
                    {
                        "title": "استخراج رقم اليوم",
                        "inputs": ["2025-11-12"],
                        "logic": lambda vals: (
                            f"رقم اليوم هو: {datetime.date.fromisoformat(vals[0].strip()).day}"
                            if vals and vals[0].strip()
                            else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD"
                        ),
                        "sidebar": "📅 استخراج رقم اليوم:\n\n"
                                "استخدم date.day للحصول على رقم اليوم من كائن التاريخ.\n\n"
                                "📥 الإدخال: تاريخ بصيغة YYYY-MM-DD\n"
                                "📤 الناتج: عدد صحيح من 1 إلى 31\n\n"
                                "🌟 مثال:\n"
                                "2025-11-12 → 12"
                    }
                ]
            },
            "min": {
                "definition": "date ترجع أقدم تاريخ ممكن تمثيله باستخدام كائن",
                "syntax": "datetime.date.min",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل التاريخ: 0001-01-01 date كائن ",
                "examples": [
                    {
                        "title": "عرض أقدم تاريخ ممكن",
                        "inputs": [],
                        "logic": lambda vals: f"أقدم تاريخ ممكن هو: {datetime.date.min}",
                        "sidebar": "📅 أقدم تاريخ ممكن:\n\n"
                                "استخدم date.min للحصول على أقدم تاريخ ممكن تمثيله.\n\n"
                                "📤 الناتج: 0001-01-01"
                    }
                ]
            },
            "max": {
                "definition": "date ترجع أحدث تاريخ ممكن تمثيله باستخدام كائن",
                "syntax": "datetime.date.max",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل التاريخ: 9999-12-31 date كائن ",
                "examples": [
                    {
                        "title": "عرض أحدث تاريخ ممكن",
                        "inputs": [],
                        "logic": lambda vals: f"أحدث تاريخ ممكن هو: {datetime.date.max}",
                        "sidebar": "📅 أحدث تاريخ ممكن:\n\n"
                                "استخدم date.max للحصول على أحدث تاريخ ممكن تمثيله.\n\n"
                                "📤 الناتج: 9999-12-31"
                    }
                ]
            },
            "resolution": {
                "definition": " وهي يوم واحد dateترجع أصغر وحدة زمنية ممكنة لكائن .",
                "syntax": "datetime.date.resolution",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل يوم واحد timedelta كائن  .",
                "examples": [
                    {
                        "title": "عرض دقة كائن التاريخ",
                        "inputs": [],
                        "logic": lambda vals: f"أصغر وحدة زمنية هي: {datetime.date.resolution}",
                        "sidebar": "⏱️ دقة كائن التاريخ:\n\n"
                                "استخدم date.resolution لمعرفة أصغر وحدة زمنية ممكنة.\n\n"
                                "📤 الناتج: timedelta(days=1)\n\n"
                                "💡 يعني أن كائن date لا يمثل أجزاء من اليوم، فقط الأيام الكاملة."
                    }
                ]
            }
        },
        "datetime.time الموديل_الكلاس":{
            "isoformat": {
                "definition": "'HH:MM:SS.ssssss' مثل ISO 8601ترجع الوقت بصيغة ",
                "syntax": "time_object.isoformat()",
                "params": "لا تأخذ معاملات.",
                "return": "ISO سلسلة نصية تمثل الوقت بصيغة .",
                "examples": [
                    {
                        "title": "ISO تحويل وقت إلى صيغة ",
                        "inputs": ["14", "30", "45", "123456"],
                        "logic": lambda vals: (
                            f"الوقت بصيغة ISO هو: {datetime.time(int(vals[0]), int(vals[1]), int(vals[2]), int(vals[3])).isoformat()}"
                            if len(vals) == 4 and all(v.strip().isdigit() for v in vals)
                            else "يرجى إدخال 4 أرقام: الساعة، الدقيقة، الثانية، والميكروثانية"
                        ),
                    }
                ]
            },
            "strftime(format)": {
                "definition": "%H و %M ترجع الوقت كنص منسّق حسب القالب الذي تحدده باستخدام رموز مثل .",
                "syntax": "time_object.strftime(format)",
                "params": "format: '%H:%M:%S' سلسلة تحتوي رموز تنسيق مثل ",
                "return": "سلسلة نصية تمثل الوقت حسب التنسيق المطلوب",
                "examples": [
                    {
                        "title": "تنسيق الوقت حسب قالب مخصص",
                        "inputs": ["الساعة", "الدقيقة", "الثانية", "%H:%M:%S"],
                        "logic": lambda vals: (
                            "يرجى إدخال الساعة والدقيقة والثانية والقالب مثل '%H:%M:%S'"
                            if len(vals) < 4 or not all(v.strip().isdigit() for v in vals[:3])
                            else (
                                lambda h, m, s, fmt: f"الوقت بالتنسيق '{fmt}' هو: {datetime.time(h, m, s).strftime(fmt)}"
                            )(
                                int(vals[0]), int(vals[1]), int(vals[2]), vals[3]
                            )
                        ),
                    }
                ]
            },
            "replace": {
                "definition": "ترجع نسخة جديدة من كائن الوقت مع تعديل القيم المحددة.",
                "syntax": "time_object.replace(hour=..., minute=..., second=..., microsecond=...)",
                "params": "أي من القيم: hour, minute, second, microsecond",
                "return": "كائن وقت جديد بالقيم المعدلة",
                "examples": [
                    {
                        "title": "تعديل الساعة والدقيقة",
                        "inputs": [
                            "14", "30", "45", "123456", "hour=9", "minute=15", "second=50", "microsecond=999999"
                        ],
                        "logic": lambda vals: (
                            "يرجى إدخال الساعة والدقيقة والثانية والميكروثانية كأرقام صحيحة."
                            if len(vals) < 4 or not all(v.strip().isdigit() for v in vals[:4])
                            else (
                                lambda h, m, s, us, mods: (
                                    f"الوقت قبل التعديل: {datetime.time(h, m, s, us)}\n"
                                    f"الوقت بعد التعديل: {datetime.time(h, m, s, us).replace(**mods)}"
                                    if mods else f"الوقت الأصلي بدون تعديل هو: {datetime.time(h, m, s, us)}"
                                )
                            )(
                                int(vals[0]), int(vals[1]), int(vals[2]), int(vals[3]),
                                {
                                    k: int(v) for k, v in (
                                        (v.split('=')[0], v.split('=')[1])
                                        for v in vals[4:]
                                        if '=' in v and v.split('=')[0] in ['hour', 'minute', 'second', 'microsecond'] and v.split('=')[1].isdigit()
                                    )
                                }
                            )
                        ),
                    }
                ]
            },
            "hour": {
                "definition": "ترجع رقم الساعة من كائن الوقت.",
                "syntax": "time_object.hour",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح من 0 إلى 23",
                "examples": [
                    {
                        "title": "استخراج الساعة",
                        "inputs": ["14", "30", "45"],
                        "logic": lambda vals: (
                            f"الساعة هي: {datetime.time(int(vals[0]), int(vals[1]), int(vals[2])).hour}"
                            if len(vals) == 3 and all(v.strip().isdigit() for v in vals)
                            else "يرجى إدخال الساعة والدقيقة والثانية"
                        ),
                    }
                ]
            },
            "minute": {
                "definition": "ترجع رقم الدقيقة من كائن الوقت.",
                "syntax": "time_object.minute",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح من 0 إلى 59",
                "examples": [
                    {
                        "title": "استخراج الدقيقة",
                        "inputs": ["14", "30", "45"],
                        "logic": lambda vals: (
                            f"الدقيقة هي: {datetime.time(int(vals[0]), int(vals[1]), int(vals[2])).minute}"
                            if len(vals) == 3 and all(v.strip().isdigit() for v in vals)
                            else "يرجى إدخال الساعة والدقيقة والثانية"
                        ),
                    }
                ]
            },
            "second": {
                "definition": "ترجع رقم الثانية من كائن الوقت.",
                "syntax": "time_object.second",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح من 0 إلى 59",
                "examples": [
                    {
                        "title": "استخراج الثانية",
                        "inputs": ["14", "30", "45"],
                        "logic": lambda vals: (
                            f"الثانية هي: {datetime.time(int(vals[0]), int(vals[1]), int(vals[2])).second}"
                            if len(vals) == 3 and all(v.strip().isdigit() for v in vals)
                            else "يرجى إدخال الساعة والدقيقة والثانية"
                        ),
                    }
                ]
            },
            "microsecond": {
                "definition": "ترجع رقم الميكروثانية من كائن الوقت.",
                "syntax": "time_object.microsecond",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح من 0 إلى 999999",
                "examples": [
                    {
                        "title": "استخراج الميكروثانية",
                        "inputs": ["14", "30", "45", "123456"],
                        "logic": lambda vals: (
                            f"الميكروثانية هي: {datetime.time(int(vals[0]), int(vals[1]), int(vals[2]), int(vals[3])).microsecond}"
                            if len(vals) == 4 and all(v.strip().isdigit() for v in vals)
                            else "يرجى إدخال الساعة والدقيقة والثانية والميكروثانية"
                        ),
                    }
                ]
            },
            "min": {
                "definition": "ترجع أقل وقت ممكن تمثيله (00:00:00).",
                "syntax": "datetime.time.min",
                "params": "لا تأخذ معاملات.",
                "return": "كائن وقت يمثل منتصف الليل",
                "examples": [
                    {
                        "title": "عرض أقل وقت ممكن",
                        "inputs": [],
                        "logic": lambda vals: f"أقل وقت ممكن هو: {datetime.time.min}",
                        "sidebar": "🕒 أقل وقت ممكن:\n\n"
                                "استخدم time.min للحصول على أقل وقت ممكن تمثيله.\n\n"
                                "📤 الناتج: 00:00:00"
                    }
                ]
            },
            "max": {
                "definition": "ترجع أكبر وقت ممكن تمثيله (23:59:59.999999).",
                "syntax": "datetime.time.max",
                "params": "لا تأخذ معاملات.",
                "return": "كائن وقت يمثل نهاية اليوم",
                "examples": [
                    {
                        "title": "عرض أكبر وقت ممكن",
                        "inputs": [],
                        "logic": lambda vals: f"أكبر وقت ممكن هو: {datetime.time.max}",
                        "sidebar": "🕒 أكبر وقت ممكن:\n\n"
                                "استخدم time.max للحصول على أكبر وقت ممكن تمثيله.\n\n"
                                "📤 الناتج: 23:59:59.999999"
                    }
                ]
            },
            "resolution": {
                "definition": "ترجع أصغر وحدة زمنية ممكنة لكائن time، وهي ميكروثانية واحدة.",
                "syntax": "datetime.time.resolution",
                "params": "لا تأخذ معاملات.",
                "return": "كائن timedelta يمثل ميكروثانية واحدة",
                "examples": [
                    {
                        "title": "عرض دقة كائن الوقت",
                        "inputs": [],
                        "logic": lambda vals: f"أصغر وحدة زمنية هي: {datetime.time.resolution}",
                        "sidebar": "⏱️ دقة كائن الوقت:\n\n"
                                "استخدم time.resolution لمعرفة أصغر وحدة زمنية ممكنة.\n\n"
                                "📤 الناتج: timedelta(microseconds=1)\n\n"
                                "💡 يعني أن كائن time لا يمثل أجزاء أصغر من الميكروثانية."
                    }
                ]
            }
        },
        "datetime.timedelta الموديل_الكلاس ":{
            "timedelta": {
                "definition": "كائن يمثل فرقًا زمنيًا بين نقطتين زمنيتين.",
                "syntax": "datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)",
                "params": "كل المعاملات اختيارية، وتُحوّل داخليًا إلى أيام وميكروثواني.",
                "return": "يمثل الفرق الزمني المطلوب timedeltaكائن  .",
                "examples": [
                    {
                        "title": "إنشاء فرق زمني 3 أيام و5 ساعات",
                        "inputs": ["السنة","الشهر","اليوم","الساعة","الدقيقة","عدد الايام المراد اضافتها","عدد الساعات المراد اضافتها"],
                        "logic": lambda vals: (
                            "يرجى إدخال 7 قيم: السنة، الشهر، اليوم، الساعة، الدقيقة، عدد الأيام، عدد الدقائق."
                            if len(vals) < 7 or not all(v.strip().isdigit() for v in vals[:7])
                            else (
                                lambda y, mo, d, h, mi, add_days, add_minutes: (
                                    f"🕒 الوقت الأساسي: {datetime.datetime(y, mo, d, h, mi)}\n"
                                    f"📆 الفرق الزمني: {datetime.timedelta(days=add_days, minutes=add_minutes)}\n"
                                    f"📤 الناتج بعد الإضافة: {datetime.datetime(y, mo, d, h, mi) + datetime.timedelta(days=add_days, minutes=add_minutes)}"
                                )
                            )(
                                int(vals[0]), int(vals[1]), int(vals[2]), int(vals[3]), int(vals[4]),
                                int(vals[5]), int(vals[6])
                            )
                        ),
                        "sidebar": "📆 إنشاء فرق زمني:\n\n"
                                "استخدم timedelta(days=3, hours=5) لإنشاء مدة زمنية.\n\n"
                                "📤 الناتج: 3 days, 5:00:00"
                    }
                ]
            },
            "total_seconds": {
                "definition": "تحسب الفرق الزمني الكامل بوحدة الثواني (كعدد عشري).",
                "syntax": "timedelta.total_seconds()",
                "params": "لا تأخذ معاملات.",
                "return": "عدد عشري يمثل مجموع الثواني.",
                "examples": [
                    {
                        "title": "حساب مجموع الثواني في فرق زمني",
                        "inputs": ["عدد الأيام","عدد الساعات","عدد الدقائق","عدد الثواني","عدد الميكروثواني"],
                        "logic": lambda vals: (
                            "أدخل حتى 5 قيم (اختياري): الأيام، الساعات، الدقائق، الثواني، الميكروثواني."
                            if not vals or all(v.strip() == "" for v in vals)
                            else (
                                lambda d, h, m, s, us: (
                                    f"⏱️ الفرق الزمني: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)}\n"
                                    f"📤 مجموع الثواني: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us).total_seconds()}"
                                )
                            )(
                                int(vals[0]) if len(vals) > 0 and vals[0].strip().isdigit() else 0,
                                int(vals[1]) if len(vals) > 1 and vals[1].strip().isdigit() else 0,
                                int(vals[2]) if len(vals) > 2 and vals[2].strip().isdigit() else 0,
                                int(vals[3]) if len(vals) > 3 and vals[3].strip().isdigit() else 0,
                                int(vals[4]) if len(vals) > 4 and vals[4].strip().isdigit() else 0
                            )
                        ),
                    }
                ]
            },
            "days": {
                "definition": "timedelta ترجع عدد الأيام داخل كائن .",
                "syntax": "timedelta.days",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح يمثل الأيام.",
                "examples": [
                    {
                        "title": "عرض عدد الأيام",
                        "inputs": ["عدد الأيام","عدد الساعات","عدد الدقائق","عدد الثواني","عدد الميكروثواني"],
                        "logic": lambda vals: (
                            "أدخل حتى 5 قيم (اختياري): الأيام، الساعات، الدقائق، الثواني، الميكروثواني."
                            if not vals or all(v.strip() == "" for v in vals)
                            else (
                                lambda d, h, m, s, us: (
                                    f"⏱️ الفرق الزمني: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)}\n"
                                    f"📆 عدد الأيام: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us).days}"
                                )
                            )(
                                int(vals[0]) if len(vals) > 0 and vals[0].strip().isdigit() else 0,
                                int(vals[1]) if len(vals) > 1 and vals[1].strip().isdigit() else 0,
                                int(vals[2]) if len(vals) > 2 and vals[2].strip().isdigit() else 0,
                                int(vals[3]) if len(vals) > 3 and vals[3].strip().isdigit() else 0,
                                int(vals[4]) if len(vals) > 4 and vals[4].strip().isdigit() else 0
                            )
                        ),
                    }
                ]
            },
            "seconds": {
                "definition": "ترجع عدد الثواني المتبقية بعد حساب الأيام.",
                "syntax": "timedelta.seconds",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح يمثل الثواني.",
                "examples": [
                    {
                        "title": "عرض عدد الثواني",
                        "inputs": ["عدد الأيام","عدد الساعات","عدد الدقائق","عدد الثواني","عدد الميكروثواني"],
                        "logic": lambda vals: (
                            "أدخل حتى 5 قيم (اختياري): الأيام، الساعات، الدقائق، الثواني، الميكروثواني."
                            if not vals or all(v.strip() == "" for v in vals)
                            else (
                                lambda d, h, m, s, us: (
                                    f"⏱️ الفرق الزمني: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)}\n"
                                    f"⏳ الثواني المتبقية بعد الأيام: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us).seconds}"
                                )
                            )(
                                int(vals[0]) if len(vals) > 0 and vals[0].strip().isdigit() else 0,
                                int(vals[1]) if len(vals) > 1 and vals[1].strip().isdigit() else 0,
                                int(vals[2]) if len(vals) > 2 and vals[2].strip().isdigit() else 0,
                                int(vals[3]) if len(vals) > 3 and vals[3].strip().isdigit() else 0,
                                int(vals[4]) if len(vals) > 4 and vals[4].strip().isdigit() else 0
                            )
                        ),
                    }
                ]
            },
            "microseconds": {
                "definition": "ترجع عدد الميكروثواني داخل الفرق الزمني.",
                "syntax": "timedelta.microseconds",
                "params": "لا تأخذ معاملات.",
                "return": "عدد صحيح يمثل الميكروثواني.",
                "examples": [
                    {
                        "title": "عرض عدد الميكروثواني",
                        "inputs": ["عدد الأيام","عدد الساعات","عدد الدقائق","عدد الثواني","عدد الميكروثواني"],
                        "logic": lambda vals: (
                            "أدخل حتى 5 قيم (اختياري): الأيام، الساعات، الدقائق، الثواني، الميكروثواني."
                            if not vals or all(v.strip() == "" for v in vals)
                            else (
                                lambda d, h, m, s, us: (
                                    f"⏱️ الفرق الزمني: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)}\n"
                                    f"⚡ عدد الميكروثواني المتبقية: {datetime.timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us).microseconds}"
                                )
                            )(
                                int(vals[0]) if len(vals) > 0 and vals[0].strip().isdigit() else 0,
                                int(vals[1]) if len(vals) > 1 and vals[1].strip().isdigit() else 0,
                                int(vals[2]) if len(vals) > 2 and vals[2].strip().isdigit() else 0,
                                int(vals[3]) if len(vals) > 3 and vals[3].strip().isdigit() else 0,
                                int(vals[4]) if len(vals) > 4 and vals[4].strip().isdigit() else 0
                            )
                        ),
                    }
                ]
            },
            "min": {
                "definition": "أقل فرق زمني ممكن تمثيله (سالب 999999999 يوم).",
                "syntax": "datetime.timedelta.min",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل أقل فرق زمني ممكن timedeltaكائن ",
                "examples": [
                    {
                        "title": "عرض أقل فرق زمني",
                        "inputs": [],
                        "logic": lambda vals: f"أقل فرق زمني هو: {datetime.timedelta.min}",
                        "sidebar": "📉 أقل فرق زمني:\n\n"
                                "استخدم timedelta.min للحصول على أقل فرق زمني ممكن.\n\n"
                                "📤 الناتج: -999999999 days, 0:00:00"
                    }
                ]
            },
            "max": {
                "definition": "أكبر فرق زمني ممكن تمثيله (999999999 يوم).",
                "syntax": "datetime.timedelta.max",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل أكبر فرق زمني ممكن timedeltaكائن ",
                "examples": [
                    {
                        "title": "عرض أكبر فرق زمني",
                        "inputs": [],
                        "logic": lambda vals: f"أكبر فرق زمني هو: {datetime.timedelta.max}",
                        "sidebar": "📈 أكبر فرق زمني:\n\n"
                                "استخدم timedelta.max للحصول على أكبر فرق زمني ممكن.\n\n"
                                "📤 الناتج: 999999999 days, 23:59:59.999999"
                    }
                ]
            },
            "resolution": {
                "definition": "وهي ميكروثانية واحدة timedeltaأصغر وحدة زمنية ممكنة داخل",
                "syntax": "datetime.timedelta.resolution",
                "params": "لا تأخذ معاملات.",
                "return": "يمثل ميكروثانية واحدة timedeltaكائن ",
                "examples": [
                    {
                        "title": "عرض دقة الفرق الزمني",
                        "inputs": [],
                        "logic": lambda vals: f"دقة الفرق الزمني هي: {datetime.timedelta.resolution}",
                        "sidebar": "🧪 دقة الفرق الزمني:\n\n"
                                "استخدم timedelta.resolution للحصول على أصغر وحدة زمنية ممكنة.\n\n"
                                "📤 الناتج: 0:00:00.000001"
                    }
                ]
            }
        },
        "datetime.timezone الموديل_الكلاس":{
            "timezone": {
                "definition": "datetime ويُستخدم لتحديد المنطقة الزمنية لكائن UTC عن (offset)كائن يمثل فرق التوقيت .\n ، ويمكن تحديد اسم مخصص للمنطقة timedelta يُنشأ باستخدام .",
                "syntax": "datetime.timezone(offset: timedelta, name: str = None)",
                "params": "offset: UTC (timedelta) فرق التوقيت عن \n name: (str) اسم اختياري للمنطقة الزمنية ",
                "return": "لتحديد المنطقة الزمنية بدقة datetime يُستخدم مع timezoneكائن ",
                "examples": [
                    {
                        "title": "إنشاء منطقة زمنية (+رقم) ساعات",
                        "inputs": ["offset=رقم"],
                        "logic": lambda vals: (
                            lambda tz: f"✅ تم إنشاء المنطقة الزمنية: {tz} | فرق التوقيت: {tz.utcoffset(None)}"
                        )(datetime.timezone(datetime.timedelta(hours=int(vals[0].split('=')[1]))))
                        if len(vals) == 1 and vals[0].startswith("offset=")
                        else "يرجى إدخال فرق التوقيت بصيغة offset=عدد الساعات"
                    },
                    {
                        "title": "datetime بكائن timezone ربط",
                        "inputs": ["2025-11-13 00:30", "offset=رقم"],
                        "logic": lambda vals: (
                            lambda dt, tz: f"📅 التاريخ مع المنطقة الزمنية: {dt.replace(tzinfo=tz)}"
                        )(
                            datetime.datetime.strptime(vals[0], "%Y-%m-%d %H:%M"),
                            datetime.timezone(datetime.timedelta(hours=int(vals[1].split('=')[1])))
                        )
                        if len(vals) == 2 and all(v.strip() for v in vals)
                        else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD HH:MM وفرق التوقيت بصيغة offset=عدد"
                    }
                ],
                        "sidebar": "🕓 كائن timezone:\n\n"
                        "timezone(timedelta(hours=3)) → فرق توقيت +3 ساعات\n"
                        "datetime(..., tzinfo=timezone.utc) → توقيت UTC\n"
                        "يمكن استخدامه مع astimezone() لتحويل المناطق الزمنية"
            },
            "utcoffset(dt)": {
                "definition": " المرتبط بمنطقة زمنية معينة datetime لكائن UTC عن (offset)ترجع فرق التوقيت .\n أو عند تحليل الفروقات الزمنية astimezone() تُستخدم غالبًا داخل  .",
                "syntax": "timezone.utcoffset(dt)",
                "params": "dt: (tzinfo) مرتبط بمنطقة زمنية datetime كائن ",
                "return": " (مثلاً: timedelta(hours=3)) UTC يمثل فرق التوقيت عن timedelta كائن ",
                "examples": [
                    {
                        "title": "فرق التوقيت لمنطقة ",
                        "inputs": ["2025-11-13 12:00", "offset=3"],
                        "logic": lambda vals: (
                            lambda dt, tz: f"فرق التوقيت لـ {dt.strftime('%Y-%m-%d %H:%M')} هو: {tz.utcoffset(dt)}"
                        )(
                            datetime.datetime.strptime(vals[0], "%Y-%m-%d %H:%M"),
                            datetime.timezone(datetime.timedelta(hours=int(vals[1].split('=')[1])))
                        )
                        if len(vals) == 2 and vals[1].startswith("offset=")
                        else "يرجى إدخال التاريخ بصيغة YYYY-MM-DD HH:MM وفرق التوقيت بصيغة offset=عدد"
                    }
                ]
            },
            "dst(dt)": {
                "definition": "datetime لكائن (Daylight Saving Time) ترجع فرق التوقيت الصيفي   .\n أو صفر لأن التوقيت الصيفي غير مفعّل None العادي,دائمًا ترجع timezone في كائن",
                "syntax": "timezone.dst(dt)",
                "params": "dt: مرتبط بمنطقة زمنية datetimeكائن  ",
                "return": "ZoneInfo إلا إذا تم استخدام لمنطقة فيها توقيت صيفي timedelta(0) أو Noneترجع عادةً ",
                "examples": [
                    {
                        "title": "timezone فرق التوقيت الصيفي لمنطقة ",
                        "inputs": ["offset=2"],
                        "logic": lambda vals: (
                            lambda tz: f"فرق التوقيت الصيفي: {tz.dst(None)}"
                        )(datetime.timezone(datetime.timedelta(hours=int(vals[0].split('=')[1]))))
                        if len(vals) == 1 and vals[0].startswith("offset=")
                        else "يرجى إدخال فرق التوقيت بصيغة offset=عدد الساعات"
                    }
                ]
            },
            "tzname(dt)": {
                "definition": "timezone ترجع اسم المنطقة الزمنية المرتبطة بكائن .\n UTC+03:00 إذا لم يتم تحديد اسم عند الإنشاء، يتم توليد اسم تلقائي مثل .",
                "syntax": "timezone.tzname(dt)",
                "params": "dt: مرتبط بمنطقة زمنية datetimeكائن  ",
                "return": " 'UTC+03:00' أو الاسم المخصص إذا تم تحديده مثل (str) اسم المنطقة الزمنية كنص",
                "examples": [
                    {
                        "title": "اسم المنطقة الزمنية بدون اسم مخصص",
                        "inputs": ["offset=3"],
                        "logic": lambda vals: (
                            lambda tz: f"اسم المنطقة الزمنية: {tz.tzname(None)}"
                        )(datetime.timezone(datetime.timedelta(hours=int(vals[0].split('=')[1]))))
                        if len(vals) == 1 and vals[0].startswith("offset=")
                        else "يرجى إدخال فرق التوقيت بصيغة offset=عدد الساعات"
                    },
                    {
                        "title": "اسم مخصص للمنطقة الزمنية",
                        "inputs": ["offset=3", "Asia/Damascus"],
                        "logic": lambda vals: (
                            lambda tz: f"اسم مخصص: {tz.tzname(None)}"
                        )(datetime.timezone(datetime.timedelta(hours=int(vals[0].split('=')[1])), name=vals[1]))
                        if len(vals) == 2 and vals[0].startswith("offset=")
                        else "يرجى إدخال offset=عدد الساعات واسم مخصص للمنطقة",
                        "sidebar": "🕵️‍♂️ ملاحظة مهمة:\n\n"
                                   " لا يعرف أسماء المدن أو المناطق الجغرافية timezoneكائن .\n"
                                   " حسب فرق التوقيت UTC+03:00 ترجع اسم تلقائي مثل tzname()الدالة.\n"
                                   "إذا تم تحديد اسم مخصص عند إنشاء الكائن، يتم عرضه كما هو، حتى لو لا يمثل منطقة حقيقية.\n\n"
                                   "📌 UTC إذا أراد المبرمج إدخال اسم مدينة، يجب أن يكون عارف مسبقًا بفرق توقيتها عن \n\n لا يحسبه تلقائيًا timezone لأن"
                    }
                ]
            }
        },
        "zoneinfo.ZoneInfo الموديل_الكلاس":{
            "ZoneInfo": {
                "definition": "IANA كائن يمثل منطقة زمنية حقيقية باستخدام قاعدة بيانات .\n 'Asia/Damascus' يُستخدم مع datetime لتحديد المنطقة الزمنية بدقة مثل .",
                "syntax": "ZoneInfo(key: str)",
                "params": "key: 'Europe/London' مثل (str) اسم المنطقة الزمنية بصيغة IANA  ",
                "return": "datetime يُستخدم لتحديد المنطقة الزمنية داخل ZoneInfoكائن   ",
                "examples": [
                    {
                        "title": "كائن  لمنطقة دمشق ZoneInfoإنشاء ",
                        "inputs": ["Asia/Damascus"],
                        "logic": lambda vals: (
                            lambda tz: f"✅ تم إنشاء المنطقة الزمنية: {tz}"
                        )(ZoneInfo(vals[0])) if len(vals) == 1 else "يرجى إدخال اسم منطقة زمنية مثل Asia/Damascus",
                    },
                    {
                        "title": "مع منطقة زمنية datetimeربط",
                        "inputs": ["2025-11-13 10:00", "Asia/Damascus"],
                        "logic": lambda vals: (
                            lambda dt, tz: f"📅 التاريخ مع المنطقة الزمنية: {dt.replace(tzinfo=tz)}"
                        )(
                            datetime.datetime.strptime(vals[0], "%Y-%m-%d %H:%M"),
                            ZoneInfo(vals[1])
                        ) if len(vals) == 2 else "يرجى إدخال التاريخ واسم المنطقة الزمنية",
                    
                        "sidebar":  "🌍 كائن ZoneInfo:\n\n"
                                    "ZoneInfo('Asia/Damascus') → يمثل توقيت دمشق حسب قاعدة بيانات IANA\n"
                                    "يُستخدم مع datetime لتحديد المنطقة الزمنية بدقة.\n"
                                    "يجب أن يكون اسم المنطقة صحيحًا ومعروفًا في النظام أو ضمن مكتبة tzdata.\n"
                                    "يمكن استخدامه مع astimezone() للتحويل بين المناطق الزمنية."
                    }                
                ]
            }
        },
        "calendar.calendar الموديل والكلاس ":{
            "calendarمقدمة": {
                "definition": "وحدة تُستخدم لطباعة التقاويم، والتحقق من السنوات الكبيسة، وتحديد أيام الأسبوع.",
                "syntax": "import calendar",
                "params": "month(), isleap(), weekday() لا توجد معاملات مباشرة، يتم استخدام دوال مثل ",
                "return": "نتائج نصية أو منطقية حسب الدالة المستخدمة",
                "examples": [
                    {
                        "title": "طباعة تقويم شهر معين",
                        "inputs": ["السنة", "الشهر"],
                        "logic": lambda vals: (
                            calendar.month(int(vals[0]), int(vals[1]))
                        ) if len(vals) == 2 else "يرجى إدخال السنة والشهر مثل 2025, 11"
                    },
                    {
                        "title": "التحقق من سنة كبيسة",
                        "inputs": ["السنة"],
                        "logic": lambda vals: (
                            f"هل السنة كبيسة؟ {calendar.isleap(int(vals[0]))}"
                        ) if len(vals) == 1 else "يرجى إدخال سنة واحدة مثل 2024"
                    },
                    {
                        "title": "تحديد يوم الأسبوع لتاريخ معين",
                        "inputs": ["السنة", "رقم الشهر", "رقم اليوم"],
                        "logic": lambda vals: (
                            f"رقم اليوم: {calendar.weekday(int(vals[0]), int(vals[1]), int(vals[2]))}"
                        ) if len(vals) == 3 else "يرجى إدخال التاريخ بصيغة: سنة، شهر، يوم",
                        "sidebar": "📅 وحدة calendar:\n\n"
                                "تُستخدم لطباعة تقاويم شهرية وسنوية، والتحقق من السنوات الكبيسة.\n"
                                "calendar.isleap(2024) → True\n"
                                "calendar.weekday(2025, 1, 1) → رقم اليوم (0=الاثنين)\n"
                                "يمكنك تغيير أول يوم في الأسبوع باستخدام setfirstweekday()."
                    }
                ]
            },
            "month": {
                "definition": "ترجع تقويم شهر معين كنص منسق.",
                "syntax": "calendar.month(year: int, month: int)",
                "params": "year: (int) السنة المطلوبة\nmonth: (int) رقم الشهر من 1 إلى 12",
                "return": "سلسلة نصية تحتوي على تقويم الشهر",
                "examples": [
                    {
                        "title": "طباعة تقويم شهر نوفمبر 2025",
                        "inputs": ["2025", "11"],
                        "logic": lambda vals: (
                            calendar.month(int(vals[0]), int(vals[1]))
                        ) if len(vals) == 2 else "يرجى إدخال السنة والشهر مثل 2025, 11",
                        "sidebar": "📅 calendar.month:\n\n"
                                "ترجع تقويم الشهر كنص منسق.\n"
                                "مثال: calendar.month(2025, 11) → تقويم نوفمبر 2025"
                    }
                ]
            },
            "isleap": {
                "definition": "تتحقق إذا كانت السنة كبيسة (366 يوم).",
                "syntax": "calendar.isleap(year: int)",
                "params": "year: (int) السنة المطلوبة",
                "return": "True إذا كانت السنة كبيسة، False إذا لم تكن كذلك",
                "examples": [
                    {
                        "title": "التحقق من سنة كبيسة",
                        "inputs": ["2024"],
                        "logic": lambda vals: (
                            f"هل السنة كبيسة؟ {calendar.isleap(int(vals[0]))}"
                        ) if len(vals) == 1 else "يرجى إدخال سنة واحدة مثل 2024",
                        "sidebar": "📅 calendar.isleap:\n\n"
                                "تُستخدم للتحقق من كون السنة كبيسة.\n"
                                "مثال: calendar.isleap(2024) → True"
                    }
                ]
            },
            "weekday": {
                "definition": "ترجع رقم اليوم من الأسبوع لتاريخ معين.",
                "syntax": "calendar.weekday(year: int, month: int, day: int)",
                "params": "year: (int) السنة\nmonth: (int) رقم الشهر\nday: (int) رقم اليوم",
                "return": "رقم اليوم من الأسبوع (0=الاثنين، 6=الأحد)",
                "examples": [
                    {
                        "title": "تحديد يوم الأسبوع لتاريخ معين",
                        "inputs": ["2025", "1", "1"],
                        "logic": lambda vals: (
                            f"رقم اليوم: {calendar.weekday(int(vals[0]), int(vals[1]), int(vals[2]))}"
                        ) if len(vals) == 3 else "يرجى إدخال السنة، الشهر، واليوم مثل: 2025, 1, 1",
                        "sidebar":  "📅 calendar.weekday:\n\n"
                                    "ترجع رقم اليوم من الأسبوع لتاريخ معين.\n"
                                    "مثال: calendar.weekday(2025, 1, 1) → 2 (الأربعاء)"
                    }
                ]
            },
            "setfirstweekday": {
                "definition": "تغيّر أول يوم في الأسبوع عند عرض التقاويم.",
                "syntax": "calendar.setfirstweekday(index: int)",
                "params": "index: (int) رقم اليوم (0=الاثنين، 6=الأحد)",
                "return": "لا شيء، لكن يؤثر على تنسيق التقاويم",
                "examples": [
                    {
                        
                        "title": "تغيير أول يوم في الأسبوع وطباعة تقويم الشهر",
                        "inputs": ["6"],
                        "logic": lambda vals: (
                            calendar.setfirstweekday(int(vals[0])) or calendar.month(2025, 11)
                        ) if len(vals) == 1 else "يرجى إدخال رقم اليوم من 0 إلى 6",
                         "sidebar": "📅 calendar.setfirstweekday:\n\n"
                                    "تُستخدم لتحديد أول يوم في الأسبوع عند عرض التقاويم.\n"
                                    "لا تطبع شيئًا بنفسها، لكن تأثيرها يظهر عند استخدام دوال مثل month() أو TextCalendar.\n"
                                    "مثال: calendar.setfirstweekday(6) → يبدأ التقويم بالأحد."
                        
                    }
                ]
            },
            "monthcalendar": {
                "definition": "ترجع قائمة تحتوي على أسابيع الشهر، كل أسبوع عبارة عن قائمة من 7 أرقام.",
                "syntax": "calendar.monthcalendar(year: int, month: int)",
                "params": "year: (int) السنة\nmonth: (int) رقم الشهر",
                "return": "قائمة ثنائية الأبعاد تمثل أسابيع الشهر",
                "examples": [
                    {
                        "title": "عرض أسابيع شهر نوفمبر 2025",
                        "inputs": ["2025", "11"],
                        "logic": lambda vals: (
                            calendar.monthcalendar(int(vals[0]), int(vals[1]))
                        ) if len(vals) == 2 else "يرجى إدخال السنة والشهر مثل 2025, 11",
                        "sidebar": "📅 calendar.monthcalendar:\n\n"
                                   "ترجع قائمة تحتوي على أسابيع الشهر.\n"
                                   "كل أسبوع عبارة عن قائمة من 7 أرقام تمثل الأيام."
                    }
                ]
            },
            "calendar(year: int)": {
                "definition": "ترجع تقويم السنة كاملة كنص منسق.",
                "syntax": "calendar.calendar(year: int)",
                "params": "year: (int) السنة المطلوبة",
                "return": "سلسلة نصية تحتوي على تقويم السنة",
                "examples": [
                    {
                        "title": "طباعة تقويم سنة 2025",
                        "inputs": ["2025"],
                        "logic": lambda vals: (
                            calendar.calendar(int(vals[0]))
                        ) if len(vals) == 1 else "يرجى إدخال سنة واحدة مثل 2025"
                    }
                ]
            },
            "prcal": {
                "definition": "تطبع تقويم السنة مباشرة على الشاشة، مع إمكانية تحديد عدد الأشهر في كل سطر.",
                "syntax": "calendar.prcal(year: int, m: int = 3)",
                "params": "year: (int) السنة المطلوبة\nm: (int) عدد الأشهر في كل سطر (افتراضي 3)",
                "return": "لا ترجع قيمة، بل تطبع مباشرة إلى الإخراج القياسي (stdout)",
                "examples": [
                    {
                        "title": "عرض تقويم سنة باستخدام formatyear (3 أشهر بالسطر)",
                        "inputs": ["2025"],
                        "logic": lambda vals: (
                            calendar.TextCalendar().formatyear(int(vals[0]), 3)
                        ) if len(vals) == 1 else "يرجى إدخال سنة واحدة مثل: 2025"
                    },
                    {
                        "title": "عرض تقويم سنة بعدد مخصص من الأشهر بالسطر",
                        "inputs": ["2025", "4"],
                        "logic": lambda vals: calendar.TextCalendar().formatyear(int(vals[0]), m=int(vals[1]))
                    }
                ]
            }
        }
    }
}

# الاستخدام:
functions_data = unify_inputs(functions_data)
 
# نافذة المثال التفاعلي
def open_example_window(func_name, example):
    win = tk.Toplevel()
    win.title(example["title"])
    win.geometry("900x600")

    # تقسيم النافذة إلى يسار ويمين
    main_frame = tk.Frame(win)
    main_frame.pack(fill="both", expand=True)

    left_frame = tk.Frame(main_frame)
    left_frame.pack(side="left", fill="y", padx=10, pady=10)

    # ✅ Canvas + Scrollbar عمودي
    right_canvas = tk.Canvas(main_frame)
    right_scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=right_canvas.yview)
    right_canvas.configure(yscrollcommand=right_scrollbar.set)

    right_scrollbar.pack(side="right", fill="y")
    right_canvas.pack(side="right", fill="both", expand=True, padx=10, pady=10)

    # ✅ Frame داخل Canvas
    right_frame = tk.Frame(right_canvas)
    right_canvas.create_window((0, 0), window=right_frame, anchor="nw")

    def update_scroll_region(event):
        right_canvas.configure(scrollregion=right_canvas.bbox("all"))

    right_frame.bind("<Configure>", update_scroll_region)

    # عنوان المثال
    tk.Label(right_frame, text=example["title"], fg="blue", font=("Arial", 14)).pack(pady=5)

    # حقول الإدخال
    entries = []
    for param in example["inputs"]:
        frame = tk.Frame(right_frame)
        frame.pack(pady=2, anchor="w")
        tk.Label(frame, text=f"أدخل {param}: ").pack(side="left")

        entry = tk.Entry(frame)
        entry.pack(side="left")
        entries.append(entry)

        # قائمة زر يمين للنسخ واللصق
        menu = tk.Menu(entry, tearoff=0)
        menu.add_command(label="قص", command=lambda e=entry: e.event_generate("<<Cut>>"))
        menu.add_command(label="نسخ", command=lambda e=entry: e.event_generate("<<Copy>>"))
        menu.add_command(label="لصق", command=lambda e=entry: e.event_generate("<<Paste>>"))

        def show_menu(event, m=menu):
            m.tk_popup(event.x_root, event.y_root)

        entry.bind("<Button-3>", show_menu)

    # ✅ مربع عرض النتيجة مع Scrollbar أفقي
    output_frame = tk.Frame(right_frame)
    output_frame.pack(fill="both", expand=True, pady=10)

    x_scroll = tk.Scrollbar(output_frame, orient="horizontal")
    x_scroll.pack(side="bottom", fill="x")

    output_text = ScrolledText(
        output_frame,
        wrap="none",
        font=("Courier", 10),
        height=20,
        width=100,
        fg="green",
        bg=win.cget("bg"),
        relief="flat",
        borderwidth=0,
        xscrollcommand=x_scroll.set
    )
    output_text.pack(fill="both", expand=True)
    x_scroll.config(command=output_text.xview)
    output_text.config(state="disabled")

    # ✅ زر تنفيذ المثال
    def run_examples():
        try:
            values = [e.get() for e in entries]
            result = example["logic"](values)
            if isinstance(result, list):
                result = "\n".join(map(str, result))
            output_text.config(state="normal")
            output_text.delete("1.0", tk.END)
            output_text.insert(tk.END, str(result))
            output_text.config(state="disabled")
        except Exception as e:
            messagebox.showerror("خطأ", str(e))

    # ✅ عرض النص الجانبي إذا موجود
    if "sidebar" in example:
        scroll_frame = tk.Frame(left_frame)
        scroll_frame.pack(fill="both", expand=True)

        scrollbar = tk.Scrollbar(scroll_frame)
        scrollbar.pack(side="right", fill="y")

        text_widget = tk.Text(
            scroll_frame,
            width=60,
            height=25,
            font=("Courier", 10),
            bg=win.cget("bg"),
            fg="black",
            relief="flat",
            borderwidth=0,
            yscrollcommand=scrollbar.set
        )

        text_widget.insert("1.0", example["sidebar"])
        text_widget.config(state="normal")
        text_widget.bind("<Key>", lambda e: "break")
        text_widget.pack(side="left", fill="both", expand=True)

        scrollbar.config(command=text_widget.yview)

    # أزرار التحكم
    btn_frame = tk.Frame(right_frame)
    btn_frame.pack(pady=10)
    tk.Button(btn_frame, text="تنفيذ", command=run_examples).pack(side="left", padx=5)
    tk.Button(btn_frame, text="رجوع", command=win.destroy).pack(side="left", padx=5)
    tk.Button(btn_frame, text="تصدير إلى وورد", command=lambda: messagebox.showinfo("تصدير", "هنا نضيف كود التصدير")).pack(side="left", padx=5)

# أبعاد النافذة المطلوبة
window_width = 1000
window_height = 700

# أبعاد الشاشة
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()

# حساب الإحداثيات (منتصف الشاشة)
pos_x = (screen_width // 2) - (window_width // 2)
pos_y = (screen_height // 2) - (window_height // 2)

# ضبط الحجم والمكان
root.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")

# العنوان
tk.Label(root, text="PYTHON", font=("Arial", 28, "bold")).pack(pady=5)
tk.Label(root, text="دوال البايثون الجاهزة", font=("Arial", 20, "bold")).pack(pady=5)

# القوائم
main_combo = ttk.Combobox(root, values=list(functions_data.keys()))
main_combo.pack(pady=5)

sub_combo = ttk.Combobox(root, values=[])
sub_combo.pack(pady=5)

frame_funcs = tk.Frame(root)
frame_funcs.pack(side="right", padx=20, fill="y")

frame_info = tk.Frame(root)
frame_info.pack(side="left", expand=True, fill="both")

def update_sub(event):
    cat = main_combo.get()
    if cat in functions_data:
        sub_combo["values"] = list(functions_data[cat].keys())

main_combo.bind("<<ComboboxSelected>>", update_sub)


def show_functions(event):
    for w in frame_funcs.winfo_children():
        w.destroy()
    for w in frame_info.winfo_children():
        w.destroy()

    cat = main_combo.get()
    subcat = sub_combo.get()
    if cat and subcat:
        funcs = functions_data[cat][subcat]
        for i, (fname, fdata) in enumerate(funcs.items()):
            row, col = divmod(i, 2)  # يقسم الأزرار على عمودين
            tk.Button(frame_funcs, text=fname,
                      command=lambda fn=fname, fd=fdata: show_info(fn, fd)
                     ).grid(row=row, column=col, padx=5, pady=2, sticky="ew")

        # ضبط الأعمدة لتتمدد بالتساوي
        frame_funcs.grid_columnconfigure(0, weight=1)
        frame_funcs.grid_columnconfigure(1, weight=1)

sub_combo.bind("<<ComboboxSelected>>", show_functions)

# دالة الواجهة مع سكرول
def add_text(content, font_size=12, color="black"):
    scroll_needed = content.count("\n") > 3 or len(content) > 200

    if scroll_needed:
        container = tk.Frame(frame_info, bg=frame_info.cget("bg"))
        container.pack(pady=5, fill="x")

        txt = tk.Text(container, wrap="word", height=6,
                      font=("Arial", font_size, "bold"),
                      bd=0, highlightthickness=0,
                      bg=frame_info.cget("bg"))
        txt.tag_configure("center", justify="center", foreground=color)
        txt.insert("1.0", content, "center")
        txt.config(state="disabled")
        txt.pack(side=tk.LEFT, fill="both", expand=True)

        scroll = tk.Scrollbar(container, command=txt.yview)
        scroll.pack(side=tk.RIGHT, fill=tk.Y)
        txt.config(yscrollcommand=scroll.set)
    else:
        txt = tk.Text(frame_info, wrap="word", height=2,
                      font=("Arial", font_size, "bold"),
                      bd=0, highlightthickness=0,
                      bg=frame_info.cget("bg"))
        txt.tag_configure("center", justify="center", foreground=color)
        txt.insert("1.0", content, "center")
        txt.config(state="disabled")
        txt.pack(pady=5, fill="x")

# دالة إذا اردنا الواجهة بدون سكرول
#    def add_text(content, font_size=12, color="black"):
#        txt = tk.Text(frame_info, wrap="word", height=2,
#                      font=("Arial", font_size, "bold"),
#                      bd=0, highlightthickness=0,
#                      bg=frame_info.cget("bg"))  # خلفية مطابقة للإطار
#        txt.tag_configure("center", justify="center", foreground=color)
#        txt.insert("1.0", content, "center")
#        txt.config(state="disabled")
#        txt.pack(pady=5, fill="x")
    
def show_info(fname, fdata):
    for w in frame_info.winfo_children():
        w.destroy()

    add_text(fdata["definition"], font_size=12, color="blue")
    add_text(fdata["syntax"], font_size=14)
    add_text(fdata["params"], font_size=12)
    add_text(fdata["return"], font_size=14)

    # الأزرار أفقياً
    btn_frame = tk.Frame(frame_info)
    btn_frame.pack(pady=10)
    for ex in fdata["examples"]:
        tk.Button(btn_frame, text=ex["title"],
          command=lambda e=ex: open_example_window(fname, e),
          font=("Arial", 12, "bold")).pack(side="left", padx=5)

    bottom_frame = tk.Frame(frame_info)
    bottom_frame.pack(pady=10)
    tk.Button(bottom_frame, text="تصدير إلى وورد",
              command=lambda: messagebox.showinfo("تصدير", "هنا نضيف كود التصدير"),
              font=("Arial", 12, "bold")).pack(side="left", padx=5)
    tk.Button(bottom_frame, text="خروج", command=root.destroy,
              font=("Arial", 12, "bold")).pack(side="left", padx=5)
    
signature = tk.Label(
    root,
    text="✨ مشروع دوال بايثون التعليمي -اعداد المدرس وائل غنيجه ✨",
    fg="gray",
    font=("Arial", 24, "bold" , "italic")
)
signature.pack(side="bottom", pady=5)


root.mainloop()
